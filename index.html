<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>libpq-async++: Main Page</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">libpq-async++
   &#160;<span id="projectnumber">0.1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('index.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">libpq-async++ Documentation</div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#autotoc_md0">About libpq-async++</a><ul><li class="level2"><a href="#autotoc_md1">Notice</a></li>
<li class="level2"><a href="#autotoc_md2">Configuration</a><ul><li class="level3"><a href="#autotoc_md3">Required development libraries</a></li>
</ul>
</li>
<li class="level2"><a href="#autotoc_md4">Testing requirements:</a></li>
<li class="level2"><a href="#autotoc_md5">Limitations</a></li>
</ul>
</li>
<li class="level1"><a href="#autotoc_md6">Library usage</a><ul><li class="level2"><a href="#autotoc_md7">initialisation and cleanup</a></li>
<li class="level2"><a href="#autotoc_md8">The database</a></li>
<li class="level2"><a href="#autotoc_md9">Synchronous Mode</a><ul><li class="level3"><a href="#autotoc_md10">Synchronous Queries</a></li>
<li class="level3"><a href="#autotoc_md11">Synchronous Data Reader</a></li>
<li class="level3"><a href="#autotoc_md12">Synchronous Transactions and Savepoints</a></li>
<li class="level3"><a href="#autotoc_md13">Synchronous Prepared Statements</a></li>
<li class="level3"><a href="#autotoc_md14">Synchronous Large Object</a></li>
</ul>
</li>
<li class="level2"><a href="#autotoc_md15">Asynchronous Mode</a><ul><li class="level3"><a href="#autotoc_md16">Asynchronous queries</a></li>
<li class="level3"><a href="#autotoc_md17">Asynchronous Data Reader</a></li>
<li class="level3"><a href="#autotoc_md18">Asynchronous Transactions and Savepoints</a></li>
<li class="level3"><a href="#autotoc_md19">Asynchronous Prepared Statements</a></li>
</ul>
</li>
<li class="level2"><a href="#autotoc_md20">Table</a></li>
<li class="level2"><a href="#autotoc_md21">Row</a></li>
<li class="level2"><a href="#autotoc_md22">Data Reader Instance</a></li>
</ul>
</li>
<li class="level1"><a href="#autotoc_md23">Supported Features</a><ul><li class="level2"><a href="#autotoc_md24">Supported Types</a><ul><li class="level3"><a href="#autotoc_md25">Arrays</a></li>
<li class="level3"><a href="#autotoc_md26">Binary data types:</a></li>
<li class="level3"><a href="#autotoc_md27">boolean type:</a></li>
<li class="level3"><a href="#autotoc_md28">Character types:</a></li>
<li class="level3"><a href="#autotoc_md29">date/time types:</a></li>
<li class="level3"><a href="#autotoc_md30">Geometric types:</a></li>
<li class="level3"><a href="#autotoc_md31">JSON types:</a></li>
<li class="level3"><a href="#autotoc_md32">Monetary data types:</a></li>
<li class="level3"><a href="#autotoc_md33">Network types:</a></li>
<li class="level3"><a href="#autotoc_md34">Numeric types:</a></li>
<li class="level3"><a href="#autotoc_md35">Range type:</a></li>
<li class="level3"><a href="#autotoc_md36">System types:</a></li>
<li class="level3"><a href="#autotoc_md37">UUID type:</a></li>
</ul>
</li>
</ul>
</li>
<li class="level1"><a href="#autotoc_md38">Unsupported features</a><ul><li class="level2"><a href="#autotoc_md39">Asynchronous Large Object</a></li>
<li class="level2"><a href="#autotoc_md40">Unsupported types</a><ul><li class="level3"><a href="#autotoc_md41">System types:</a></li>
<li class="level3"><a href="#autotoc_md42">User types:</a></li>
<li class="level3"><a href="#autotoc_md43">Logger:</a></li>
</ul>
</li>
<li class="level2"><a href="#autotoc_md44">Thanks and Credits</a></li>
<li class="level2"><a href="#autotoc_md45">Known problems</a></li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="autotoc_md0"></a>
About libpq-async++</h1>
<p>This library is a c++ wrapper for the PostgreSQL libpq 'C' library.</p>
<p>It facilitate the usage of the library by the use of variadic templates,</p>
<p>By default, all data are fetch in binary format, which in theory should be faster than text format, for both transfer and convertion of the data, performance tests are on the way to validate that theory.</p>
<p>The other purpose of that library is to use the non-blocking IO of the libpq library, allowing developpers to use it with any event base library e.g.: libevent, libev, libuv, boost::asio and so on.</p>
<h2><a class="anchor" id="autotoc_md1"></a>
Notice</h2>
<p>The project is in it's alpha phase and bugs can still be present,</p>
<p>It havn't been tested on any other distro than Debian Stretch.</p>
<p>So if you want to use that lib do it at your own risk as long that you respect the GNU LGPL v2.1 license.</p>
<h2><a class="anchor" id="autotoc_md2"></a>
Configuration</h2>
<h3><a class="anchor" id="autotoc_md3"></a>
Required development libraries</h3>
<h4>Debian based distribution:</h4>
<div class="fragment"><div class="line">$ sudo apt-get install libpq-dev postgresql-server-dev-all \</div><div class="line">libcurl4-gnutls-dev libboost-dev uuid-dev</div></div><!-- fragment --><h4>Required dependencies</h4>
<ul>
<li>CMake 3.0.0 and up.</li>
<li>A compiler supporting, at least, c++14.</li>
<li><a href="https://www.boost.org/doc/libs/1_62_0/libs/multi_array/doc/user.html">The boost::multi_array library</a>.</li>
<li>The date library from Howard Hinnant @ <a href="https://github.com/HowardHinnant/date">https://github.com/HowardHinnant/date</a></li>
</ul>
<p>to download the required libraries you must run the following command after cloning this repo: </p><div class="fragment"><div class="line">$ git submodule update --init --recursive</div></div><!-- fragment --><h2><a class="anchor" id="autotoc_md4"></a>
Testing requirements:</h2>
<p>It is required to have a postgresql database available for testing program to work.</p>
<div class="fragment"><div class="line"><span class="comment">-- e.g.: To create a testing database named libpq_async_tests, </span></div><div class="line"><span class="comment">-- login to postgresql as superuser and execute the following queries.</span></div><div class="line">postgres=# <span class="keyword">create</span> role the_username <span class="keyword">with</span> login;</div><div class="line"><span class="comment">--CREATE ROLE</span></div><div class="line">postgres=# <span class="keyword">create</span> database libpq_async_tests <span class="keyword">with</span> owner the_username;</div><div class="line"><span class="comment">--CREATE DATABASE</span></div><div class="line">postgres=# \c libpq_async_test</div><div class="line"><span class="comment">--You are now connected to database &quot;libpq_async_tests&quot; as user &quot;postgres&quot;.</span></div><div class="line">libpq_async_tests=# <span class="keyword">create</span> extension ltree;</div><div class="line"><span class="comment">--CREATE EXTENSION</span></div></div><!-- fragment --><h2><a class="anchor" id="autotoc_md5"></a>
Limitations</h2>
<ul>
<li>Some PostgreSQL data types do not provide binary output function, for example if you try to select an ltree column in binary format PostgreSQL will throw the following exception: 'ERROR: no binary output function available for type ltree'.</li>
<li>Composite Types are not supported at the moment.</li>
<li>Is only tested on linux, other platforms support may be added in future release.</li>
</ul>
<p><b>Note that one way to use unsupported type, is to cast it as a supported type like 'text' for single value type and 'jsonb' for more complex one.</b></p>
<h1><a class="anchor" id="autotoc_md6"></a>
Library usage</h1>
<h2><a class="anchor" id="autotoc_md7"></a>
initialisation and cleanup</h2>
<p>First the library's <a class="el" href="classpq__async_1_1connection__pool.html">pq_async::connection_pool</a> must be initialized, by calling one of the two available init function, by default the maximum connection count is 20.</p>
<div class="fragment"><div class="line"><span class="comment">// to init with default connection count use that signature</span></div><div class="line"><span class="keywordtype">bool</span> do_ssl = <span class="keyword">true</span>;</div><div class="line"><span class="keywordtype">bool</span> do_crypto = <span class="keyword">true</span>;</div><div class="line"><a class="code" href="classpq__async_1_1connection__pool.html#aa4abfb4741cd35df9a6388c75fd657e0">pq_async::connection_pool::init</a>(do_ssl, do_crypto);</div><div class="line"><span class="comment">// to init with specific connection count use that one</span></div><div class="line"><span class="keywordtype">int</span> max_connection_pool_count = 5;</div><div class="line"><a class="code" href="classpq__async_1_1connection__pool.html#aa4abfb4741cd35df9a6388c75fd657e0">pq_async::connection_pool::init</a>(</div><div class="line">    max_connection_pool_count, do_ssl, do_crypto</div><div class="line">);</div></div><!-- fragment --><p>For more info on the "do_ssl" and "do_crypto" arguments see <a href="https://www.postgresql.org/docs/current/libpq-ssl.html#LIBPQ-SSL-INITIALIZE">https://www.postgresql.org/docs/current/libpq-ssl.html#LIBPQ-SSL-INITIALIZE</a></p>
<p>On program exit call the "destroy" static function to cleanup "connection_pool" ressources </p><div class="fragment"><div class="line"><a class="code" href="classpq__async_1_1connection__pool.html#afc8f7f0f1a35f632b88e1bcac1a24629">pq_async::connection_pool::destroy</a>();</div></div><!-- fragment --><h2><a class="anchor" id="autotoc_md8"></a>
The database</h2>
<p>To work with postgresql, an instance of the <a class="el" href="classpq__async_1_1database.html">pq_async::database</a> object is required.</p>
<p>Note: this call will never block because the connection is not open on "database" instantiation, to open the connection you can call "open" function. </p><div class="fragment"><div class="line"><span class="comment">// to obtain an instance, call the static function &quot;open&quot;</span></div><div class="line"><span class="keyword">auto</span> db = <a class="code" href="classpq__async_1_1database.html#a8ecaef3477c249d250ef37836a12b218">pq_async::database::open</a>(<span class="stringliteral">&quot;connection string&quot;</span>);</div><div class="line"></div><div class="line"><span class="comment">// to test if the connection is valid you can force the connection to open with</span></div><div class="line"><span class="comment">// &quot;open&quot; function of the instance, please note that the open call will block</span></div><div class="line"><span class="comment">// until the connection is opened or an error occured.</span></div><div class="line">db-&gt;open();</div><div class="line"></div><div class="line"><span class="comment">// to prevent blocking you can call the open async function.</span></div><div class="line"><span class="keyword">auto</span> cb = [](cb_error&amp; err){</div><div class="line">    <span class="comment">// will be called on connection or error.</span></div><div class="line">};</div><div class="line">db-&gt;open(<a class="code" href="namespacepq__async.html#a03a0284ccd4badf9893eb4463d77a295">async_cb</a>);</div></div><!-- fragment --><h2><a class="anchor" id="autotoc_md9"></a>
Synchronous Mode</h2>
<h3><a class="anchor" id="autotoc_md10"></a>
Synchronous Queries</h3>
<p>Queries can by any valid SQL query, all query functions are variadic template which accept any supported type of parameters (see Supported Types list below).</p>
<div class="fragment"><div class="line"><span class="comment">// to execute a statement without results</span></div><div class="line">std::string sql(<span class="stringliteral">&quot;insert into tbl_name(col_id_a, col_str_b) values ($1, $2)&quot;</span>);</div><div class="line"><span class="keyword">auto</span> n = db-&gt;execute(sql, 10, <span class="stringliteral">&quot;some text value&quot;</span>);</div><div class="line"><span class="comment">// &quot;n&quot; is the number of record processed with the query</span></div><div class="line"></div><div class="line"><span class="comment">// to fetch a single value</span></div><div class="line">std::string sql(<span class="stringliteral">&quot;select col_id_a form tbl_name where col_str_b = $1&quot;</span>);</div><div class="line"><span class="keyword">auto</span> id_a = db-&gt;query_value&lt;int32_t&gt;(sql, <span class="stringliteral">&quot;some text value&quot;</span>);</div><div class="line"></div><div class="line"><span class="comment">// to fetch a single row</span></div><div class="line"><span class="comment">// if multiple records are returned from PostgreSQL, only the first one is used</span></div><div class="line">std::string sql(<span class="stringliteral">&quot;select * form tbl_name where col_str_b = $1 limit 1&quot;</span>);</div><div class="line"><span class="keyword">auto</span> row = db-&gt;query_single(sql, <span class="stringliteral">&quot;some text value&quot;</span>);</div><div class="line"></div><div class="line"><span class="comment">// to fetch a table</span></div><div class="line">std::string sql(<span class="stringliteral">&quot;select * form tbl_name where id &gt; $1&quot;</span>);</div><div class="line"><span class="keyword">auto</span> tbl = db-&gt;query(sql, 3);</div><div class="line"></div><div class="line"><span class="comment">// to create a data reader</span></div><div class="line">std::string sql(<span class="stringliteral">&quot;select * form tbl_name where id &gt; $1&quot;</span>);</div><div class="line"><span class="keyword">auto</span> reader = db-&gt;query_reader(sql, 3);</div></div><!-- fragment --><h3><a class="anchor" id="autotoc_md11"></a>
Synchronous Data Reader</h3>
<div class="fragment"><div class="line"><span class="comment">// to create a data reader</span></div><div class="line">std::string sql(<span class="stringliteral">&quot;select * form tbl_name where id &gt; $1&quot;</span>);</div><div class="line"><span class="keyword">auto</span> reader = db-&gt;query_reader(sql, 3);</div><div class="line"></div><div class="line"><span class="keywordflow">while</span>(<span class="keyword">auto</span> row = reader-&gt;next()){</div><div class="line">    <span class="comment">// do row stuff ...</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// if you need to explicitly close the &quot;data_reader&quot; </span></div><div class="line"><span class="comment">// (even if it close itself on destruction) you can call &quot;close()&quot;</span></div><div class="line">reader-&gt;close();</div></div><!-- fragment --><h3><a class="anchor" id="autotoc_md12"></a>
Synchronous Transactions and Savepoints</h3>
<p>For more information on transactions go to: <a href="https://www.postgresql.org/docs/11/sql-begin.html">https://www.postgresql.org/docs/11/sql-begin.html</a></p>
<p>And for more information on savepoints go to: <a href="https://www.postgresql.org/docs/current/sql-savepoint.html">https://www.postgresql.org/docs/current/sql-savepoint.html</a></p>
<div class="fragment"><div class="line"><span class="comment">// to start a transaction use the &quot;begin&quot; function</span></div><div class="line">db-&gt;begin();</div><div class="line"><span class="comment">// the transaction_mode can be specified as the first argument</span></div><div class="line">db-&gt;begin(pq_async::transaction_mode::serializable);</div><div class="line"></div><div class="line"><span class="comment">// to discard all updates made after the begining of the transaction</span></div><div class="line"><span class="comment">// use the &quot;rollback&quot; function</span></div><div class="line">db-&gt;rollback();</div><div class="line"></div><div class="line"><span class="comment">// make all changes visible to others and garanteed </span></div><div class="line"><span class="comment">// to be durable if a crash occurs, call the &quot;commit&quot; function</span></div><div class="line">db-&gt;commit();</div><div class="line"></div><div class="line"><span class="comment">// to create a savepoint call &quot;set_savepoint&quot; function</span></div><div class="line">db-&gt;set_savepoint(<span class="stringliteral">&quot;my savepoint name&quot;</span>);</div><div class="line"><span class="comment">// to rollback a savepoint call &quot;rollback_savepoint&quot;</span></div><div class="line">db-&gt;rollback_savepoint(<span class="stringliteral">&quot;my savepoint name&quot;</span>);</div><div class="line"><span class="comment">// release a savepoint call &quot;release_savepoint&quot;</span></div><div class="line">db-&gt;release_savepoint(<span class="stringliteral">&quot;my savepoint name&quot;</span>);</div></div><!-- fragment --><h3><a class="anchor" id="autotoc_md13"></a>
Synchronous Prepared Statements</h3>
<div class="fragment"><div class="line"><span class="comment">// to create a prepared statement</span></div><div class="line">std::string name(<span class="stringliteral">&quot;unique statement name&quot;</span>);</div><div class="line">std::string statement(<span class="stringliteral">&quot;select $1&quot;</span>);</div><div class="line"><span class="keywordtype">bool</span> auto_deallocate = <span class="keyword">false</span>;</div><div class="line"><span class="keyword">auto</span> ps = db-&gt;prepare(name, statement, auto_deallocate);</div><div class="line"></div><div class="line"><span class="comment">// to get a previously prepared statement</span></div><div class="line"><span class="keywordtype">bool</span> auto_deallocate = <span class="keyword">false</span>;</div><div class="line"><span class="keyword">auto</span> ps = db-&gt;prepare(<span class="stringliteral">&quot;name&quot;</span>, auto_deallocate);</div><div class="line"></div><div class="line"><span class="comment">// to destroy the prepared statement</span></div><div class="line">db-&gt;deallocate(<span class="stringliteral">&quot;name&quot;</span>);</div><div class="line"></div><div class="line"><span class="comment">// exec functions</span></div><div class="line"><span class="keyword">auto</span> n = ps-&gt;execute(-1);</div><div class="line"><span class="keyword">auto</span> i = ps-&gt;query_value&lt;int32_t&gt;(-1);</div><div class="line"><span class="keyword">auto</span> r = ps-&gt;query_single(-1);</div><div class="line"><span class="keyword">auto</span> t = ps-&gt;query(-1);</div><div class="line"><span class="keyword">auto</span> dr = ps-&gt;query_reader(-1);</div><div class="line"></div><div class="line"><span class="keyword">auto</span> params = <span class="keyword">new</span> <a class="code" href="classpq__async_1_1parameters.html">pq_async::parameters</a>(-1);</div><div class="line"><span class="keyword">auto</span> n = ps-&gt;execute(-1);</div><div class="line"><span class="keyword">auto</span> i = ps-&gt;query_value&lt;int32_t&gt;(params);</div><div class="line"><span class="keyword">auto</span> r = ps-&gt;query_single(params);</div><div class="line"><span class="keyword">auto</span> t = ps-&gt;query(params);</div><div class="line"><span class="keyword">auto</span> dr = ps-&gt;query_reader(params);</div></div><!-- fragment --><h3><a class="anchor" id="autotoc_md14"></a>
Synchronous Large Object</h3>
<p>To get more info on large objects <a href="https://www.postgresql.org/docs/current/largeobjects.html">https://www.postgresql.org/docs/current/largeobjects.html</a></p>
<div class="fragment"><div class="line"><span class="comment">// to create a new large_object</span></div><div class="line"><span class="keyword">auto</span> lo = db-&gt;create_lo();</div><div class="line"><span class="comment">// the oid() function can be used to retrive the large object id and stored it</span></div><div class="line"><span class="keyword">auto</span> lo_oid = lo-&gt;oid();</div><div class="line"></div><div class="line"><span class="comment">// to get an existing large_object</span></div><div class="line"><span class="keyword">auto</span> lo = db-&gt;get_lo(lo_oid);</div><div class="line"></div><div class="line"><span class="comment">// to open the large_object for reading, writing or both</span></div><div class="line"><a class="code" href="namespacepq__async.html#a82dca5b34727da0168721ef33454fdf0">pq_async::lo_mode</a> <a class="code" href="namespacepq__async.html#af6857c633f2a695bc68aadcc34e1fb26">m</a> = <a class="code" href="namespacepq__async.html#a82dca5b34727da0168721ef33454fdf0aecae13117d6f0584c25a9da6c8f8415e">pq_async::lo_mode::read</a> | <a class="code" href="namespacepq__async.html#a82dca5b34727da0168721ef33454fdf0aefb2a684e4afb7d55e6147fbe5a332ee">pq_async::lo_mode::write</a>;</div><div class="line"><span class="keywordflow">if</span>(!lo-&gt;is_opened())</div><div class="line">    lo-&gt;open(lo_oid, m);</div><div class="line"></div><div class="line"><span class="comment">// to read from the lo</span></div><div class="line"><span class="keywordtype">int</span> nb = 1024;</div><div class="line"><span class="keywordtype">char</span>* buf[1024];</div><div class="line"><span class="comment">// if file is end is reached &quot;rb&quot; will be less then &quot;nb&quot;</span></div><div class="line">int32_t rb = lo-&gt;read(buf, nb);</div><div class="line"></div><div class="line"><span class="comment">// to write to the lo use</span></div><div class="line"><span class="keywordtype">int</span> nb = 1024;</div><div class="line"><span class="keywordtype">char</span>* buf[1024];</div><div class="line">int32_t wb = lo-&gt;write(buf, nb);</div><div class="line"></div><div class="line"><span class="comment">// to get the read write cursor location</span></div><div class="line">int64_t cur_pos = lo-&gt;tell();</div><div class="line"></div><div class="line"><span class="comment">// to set the read write cursor location</span></div><div class="line">int64_t offset = 0x5ca1ab1e;</div><div class="line"><a class="code" href="namespacepq__async.html#ad61891de27272e4bded8f5ddeaea97bf">pq_async::lo_whence</a> <a class="code" href="namespacepq__async.html#ae5482c76ba853c6572953ccce8ba9872">w</a> = lo_whence::seek_start;</div><div class="line">int64_t new_pos = lo-&gt;seek(offset, w);</div><div class="line"></div><div class="line"><span class="comment">// to resize the lo</span></div><div class="line">int64_t new_size = 0xacce1e28;</div><div class="line"><a class="code" href="namespacepq__async.html#ad61891de27272e4bded8f5ddeaea97bf">pq_async::lo_whence</a> w = lo_whence::seek_start;</div><div class="line">int64_t new_pos = lo-&gt;seek(new_size);</div><div class="line"></div><div class="line"><span class="comment">// to close the lo</span></div><div class="line">lo-&gt;close();</div><div class="line"></div><div class="line"><span class="comment">// to delete the lo</span></div><div class="line">lo-&gt;unlink();</div></div><!-- fragment --><h2><a class="anchor" id="autotoc_md15"></a>
Asynchronous Mode</h2>
<p>To learn more about async mode look at the code in ./tests/queue_tests/queue_test.cpp , ./tests/db_tests/database_test.cpp and ./tests/db_tests/data_reader_test.cpp</p>
<p>To run async queries you need to call the run function from the event_queue e.g.:</p>
<div class="fragment"><div class="line"><a class="code" href="classpq__async_1_1event__queue.html#aba950a379dae68792bde1858698372f2">pq_async::event_queue::get_default</a>()-&gt;<a class="code" href="classpq__async_1_1event__queue.html#a50542216c7055378a5ccd21445f088f4">run</a>();</div></div><!-- fragment --><p>this call will block until all work is done, and should be put into you main program loop.</p>
<p>if you prefer you can call "run_n(max_number_of_tasks)", this will only call block for the number of task requested.</p>
<p>in next release there will be a function called "run_t(max_timeout_ms)" this call will block for the specified duration, note that if 10ms is specified and the next call takes 1 second to complete the call to "run_t" will block 1 second.</p>
<h3><a class="anchor" id="autotoc_md16"></a>
Asynchronous queries</h3>
<div class="fragment"><div class="line"><span class="comment">// to execute a statement without results</span></div><div class="line">std::string sql(<span class="stringliteral">&quot;insert into tbl_name(col_id_a, col_str_b) values ($1, $2)&quot;</span>);</div><div class="line">db-&gt;execute(sql, 10, <span class="stringliteral">&quot;some text value&quot;</span>,</div><div class="line">[](<span class="keyword">const</span> cb_error&amp; err, <span class="keywordtype">int</span> n){</div><div class="line">    <span class="keywordflow">if</span>(err){</div><div class="line">        <span class="comment">//...</span></div><div class="line">    }</div><div class="line">    <span class="comment">// &quot;n&quot; is the number of record processed with the query</span></div><div class="line">});</div><div class="line"></div><div class="line"><span class="comment">// to fetch a single value</span></div><div class="line">std::string sql(<span class="stringliteral">&quot;select col_id_a form tbl_name where col_str_b = $1&quot;</span>);</div><div class="line">db-&gt;query_value&lt;int32_t&gt;(sql, <span class="stringliteral">&quot;some text value&quot;</span>,</div><div class="line">[](<span class="keyword">const</span> cb_error&amp; err, int32_t id_a){</div><div class="line">    <span class="keywordflow">if</span>(err){</div><div class="line">        <span class="comment">//...</span></div><div class="line">    }</div><div class="line">});</div><div class="line"></div><div class="line"><span class="comment">// to fetch a single row</span></div><div class="line"><span class="comment">// if multiple records are returned from PostgreSQL, only the first one is used</span></div><div class="line">std::string sql(<span class="stringliteral">&quot;select * form tbl_name where col_str_b = $1 limit 1&quot;</span>);</div><div class="line">db-&gt;query_single(sql, <span class="stringliteral">&quot;some text value&quot;</span>,</div><div class="line">[](<span class="keyword">const</span> cb_error&amp; err, <a class="code" href="namespacepq__async.html#a496df213d664fd4fbc3835f2db9dd5ea">sp_data_row</a> row){</div><div class="line">    <span class="keywordflow">if</span>(err){</div><div class="line">        <span class="comment">//...</span></div><div class="line">    }</div><div class="line">    <span class="comment">// use the row...</span></div><div class="line">});</div><div class="line"></div><div class="line"><span class="comment">// to fetch a table</span></div><div class="line">std::string sql(<span class="stringliteral">&quot;select * form tbl_name where id &gt; $1&quot;</span>);</div><div class="line">db-&gt;query(sql, 3,</div><div class="line">[](<span class="keyword">const</span> cb_error&amp; err, <a class="code" href="namespacepq__async.html#ac55315e08f6f76bc2dfb7f0cf3b27073">sp_data_table</a> tbl){</div><div class="line">    <span class="keywordflow">if</span>(err){</div><div class="line">        <span class="comment">//...</span></div><div class="line">    }</div><div class="line">    <span class="comment">// use the table...</span></div><div class="line">});</div><div class="line"></div><div class="line"><span class="comment">// to create a data reader</span></div><div class="line">std::string sql(<span class="stringliteral">&quot;select * form tbl_name where id &gt; $1&quot;</span>);</div><div class="line">db-&gt;query_reader(sql, 3,</div><div class="line">[](<span class="keyword">const</span> cb_error&amp; err, <a class="code" href="namespacepq__async.html#a44721d94c016db8d76a4360705dbe3a2">sp_data_reader</a> reader){</div><div class="line">    <span class="keywordflow">if</span>(err){</div><div class="line">        <span class="comment">//...</span></div><div class="line">    }</div><div class="line">    <span class="comment">// use the reader...</span></div><div class="line">});</div></div><!-- fragment --><h3><a class="anchor" id="autotoc_md17"></a>
Asynchronous Data Reader</h3>
<div class="fragment"><div class="line"><span class="comment">// to create a data reader</span></div><div class="line">std::string sql(<span class="stringliteral">&quot;select * form tbl_name where id &gt; $1&quot;</span>);</div><div class="line">db-&gt;query_reader(sql, 3,</div><div class="line">[](<span class="keyword">const</span> cb_error&amp; err, <a class="code" href="namespacepq__async.html#a44721d94c016db8d76a4360705dbe3a2">sp_data_reader</a> reader){</div><div class="line">    <span class="keywordflow">if</span>(err){</div><div class="line">        <span class="comment">//...</span></div><div class="line">    }</div><div class="line">    <span class="comment">// use the reader...</span></div><div class="line">    reader-&gt;next([scb, reader]</div><div class="line">    (<span class="keyword">const</span> cb_error&amp; err, <a class="code" href="namespacepq__async.html#a496df213d664fd4fbc3835f2db9dd5ea">sp_data_row</a> r){   <span class="comment">// this callback will be called</span></div><div class="line">        <span class="keywordflow">if</span>(err){                            <span class="comment">// until there is no more row to</span></div><div class="line">            scb(err);                       <span class="comment">// be processed</span></div><div class="line">            <span class="keywordflow">return</span>;</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span>(!r){</div><div class="line">            <span class="comment">// if r is empty the reader is closed</span></div><div class="line">            <span class="keywordflow">return</span>;</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="comment">// if you need to explicitly close the &quot;data_reader&quot; </span></div><div class="line">        <span class="comment">// (even if it close itself on destruction) you can call &quot;close()&quot;</span></div><div class="line">        reader-&gt;close();    <span class="comment">// NOTE that after this call the callback </span></div><div class="line">                            <span class="comment">// will be called one more time with an empty row.</span></div><div class="line"></div><div class="line">        <span class="comment">// use the data row</span></div><div class="line">        std::string v = *(*r)[<span class="stringliteral">&quot;value&quot;</span>];</div><div class="line">        std::cout</div><div class="line">            &lt;&lt; <span class="stringliteral">&quot;id: &quot;</span> &lt;&lt; r-&gt;as_int64(<span class="stringliteral">&quot;id&quot;</span>)</div><div class="line">            &lt;&lt; <span class="stringliteral">&quot;, value: &quot;</span> &lt;&lt; v &lt;&lt; std::endl;</div><div class="line">    });</div><div class="line">});</div></div><!-- fragment --><h3><a class="anchor" id="autotoc_md18"></a>
Asynchronous Transactions and Savepoints</h3>
<div class="fragment"><div class="line">For more information on transactions go to:</div><div class="line">https:<span class="comment">//www.postgresql.org/docs/11/sql-begin.html</span></div><div class="line"></div><div class="line">And <span class="keywordflow">for</span> more information on savepoints go to:</div><div class="line">https:<span class="comment">//www.postgresql.org/docs/current/sql-savepoint.html</span></div><div class="line"></div><div class="line">~~~{.cpp}</div><div class="line"><span class="comment">// to start a transaction use the &quot;begin&quot; function</span></div><div class="line">db-&gt;begin([](<span class="keyword">const</span> cb_error&amp; err){</div><div class="line">    <span class="keywordflow">if</span>(err){</div><div class="line">        <span class="comment">// ...</span></div><div class="line">    }</div><div class="line"></div><div class="line">});</div><div class="line"></div><div class="line"><span class="comment">// will be implement in a future version</span></div><div class="line"><span class="comment">// the transaction_mode can be specified as the first argument</span></div><div class="line"><span class="comment">//db-&gt;begin(pq_async::transaction_mode::serializable);</span></div><div class="line"></div><div class="line"><span class="comment">// to discard all updates made after the begining of the transaction</span></div><div class="line"><span class="comment">// use the &quot;rollback&quot; function</span></div><div class="line">db-&gt;rollback([](<span class="keyword">const</span> cb_error&amp; err){</div><div class="line">    <span class="keywordflow">if</span>(err){</div><div class="line">        <span class="comment">// ...</span></div><div class="line">    }</div><div class="line"></div><div class="line">});</div><div class="line"></div><div class="line"><span class="comment">// make all changes visible to others and garanteed </span></div><div class="line"><span class="comment">// to be durable if a crash occurs, call the &quot;commit&quot; function</span></div><div class="line">db-&gt;commit([](<span class="keyword">const</span> cb_error&amp; err){</div><div class="line">    <span class="keywordflow">if</span>(err){</div><div class="line">        <span class="comment">// ...</span></div><div class="line">    }</div><div class="line"></div><div class="line">});</div><div class="line"></div><div class="line"><span class="comment">// to create a savepoint call &quot;set_savepoint&quot; function</span></div><div class="line">db-&gt;set_savepoint(<span class="stringliteral">&quot;my savepoint name&quot;</span>, [](<span class="keyword">const</span> cb_error&amp; err){</div><div class="line">    <span class="keywordflow">if</span>(err){</div><div class="line">        <span class="comment">// ...</span></div><div class="line">    }</div><div class="line"></div><div class="line">});</div><div class="line"></div><div class="line"><span class="comment">// to rollback a savepoint call &quot;rollback_savepoint&quot;</span></div><div class="line">db-&gt;rollback_savepoint(<span class="stringliteral">&quot;my savepoint name&quot;</span>, [](<span class="keyword">const</span> cb_error&amp; err){</div><div class="line">    <span class="keywordflow">if</span>(err){</div><div class="line">        <span class="comment">// ...</span></div><div class="line">    }</div><div class="line"></div><div class="line">});</div><div class="line"></div><div class="line"><span class="comment">// release a savepoint call &quot;release_savepoint&quot;</span></div><div class="line">db-&gt;release_savepoint(<span class="stringliteral">&quot;my savepoint name&quot;</span>, [](<span class="keyword">const</span> cb_error&amp; err){</div><div class="line">    <span class="keywordflow">if</span>(err){</div><div class="line">        <span class="comment">// ...</span></div><div class="line">    }</div><div class="line"></div><div class="line">});</div></div><!-- fragment --><h3><a class="anchor" id="autotoc_md19"></a>
Asynchronous Prepared Statements</h3>
<div class="fragment"></div><!-- fragment --><h2><a class="anchor" id="autotoc_md20"></a>
Table</h2>
<p>The <a class="el" href="classpq__async_1_1data__table.html">pq_async::data_table</a> class is the representation of multiple records.</p>
<div class="fragment"></div><!-- fragment --><h2><a class="anchor" id="autotoc_md21"></a>
Row</h2>
<p>The <a class="el" href="classpq__async_1_1data__row.html">pq_async::data_row</a> class is the representation of a record.</p>
<div class="fragment"><div class="line"><span class="comment">// given the following query to fetch a single row</span></div><div class="line">std::string sql(<span class="stringliteral">&quot;select * form tbl_name where col_str_b = $1 limit 1&quot;</span>);</div><div class="line"><span class="keyword">auto</span> row = db-&gt;query_single(sql, <span class="stringliteral">&quot;some text value&quot;</span>);</div><div class="line"></div><div class="line"><span class="comment">// here is multiple ways to retrieve values from the row</span></div><div class="line"></div><div class="line"><span class="comment">// with columns name</span></div><div class="line"><span class="keyword">auto</span> <span class="keywordtype">id</span> = row-&gt;as&lt;int64_t&gt;(<span class="stringliteral">&quot;col_id_a&quot;</span>);</div><div class="line"><span class="keyword">auto</span> <span class="keywordtype">id</span> = row-&gt;as_int64(<span class="stringliteral">&quot;col_id_a&quot;</span>);</div><div class="line">int64_t <span class="keywordtype">id</span> = *(row)[<span class="stringliteral">&quot;col_id_a&quot;</span>];</div><div class="line"></div><div class="line"><span class="comment">// with columns id</span></div><div class="line"><span class="keyword">auto</span> txt = row-&gt;as&lt;std::string&gt;(1);</div><div class="line"><span class="keyword">auto</span> txt = row-&gt;as_string(1);</div><div class="line">std::string txt = *(row)[1];</div></div><!-- fragment --><h2><a class="anchor" id="autotoc_md22"></a>
Data Reader Instance</h2>
<p>TODO: document this</p>
<div class="fragment"></div><!-- fragment --><h1><a class="anchor" id="autotoc_md23"></a>
Supported Features</h1>
<h2><a class="anchor" id="autotoc_md24"></a>
Supported Types</h2>
<h3><a class="anchor" id="autotoc_md25"></a>
Arrays</h3>
<p>Array for any of the supported types, up to five dimensions.</p>
<h3><a class="anchor" id="autotoc_md26"></a>
Binary data types:</h3>
<table class="doxtable">
<tr>
<th>postgres type </th><th>OID </th><th>CPP type  </th></tr>
<tr>
<td>bytea </td><td>BYTEAOID </td><td>std::vector&lt;int8_t&gt; </td></tr>
</table>
<h3><a class="anchor" id="autotoc_md27"></a>
boolean type:</h3>
<table class="doxtable">
<tr>
<th>postgres type </th><th>OID </th><th>CPP type  </th></tr>
<tr>
<td>boolean </td><td>BOOLOID </td><td>bool </td></tr>
</table>
<h3><a class="anchor" id="autotoc_md28"></a>
Character types:</h3>
<table class="doxtable">
<tr>
<th>postgres type </th><th>OID </th><th>CPP type  </th></tr>
<tr>
<td>varchar(n) </td><td>VARCHAROID </td><td>std::string </td></tr>
<tr>
<td>char(n) </td><td>BPCHAROID </td><td>std::string </td></tr>
<tr>
<td>text </td><td>TEXTOID </td><td>std::string </td></tr>
</table>
<h3><a class="anchor" id="autotoc_md29"></a>
date/time types:</h3>
<table class="doxtable">
<tr>
<th>postgres type </th><th>OID </th><th>CPP type  </th></tr>
<tr>
<td>timestamp without time zone </td><td>TIMESTAMPOID </td><td><a class="el" href="classpq__async_1_1timestamp.html">pq_async::timestamp</a> </td></tr>
<tr>
<td>timestamp with time zone </td><td>TIMESTAMPTZOID </td><td><a class="el" href="classpq__async_1_1timestamp__tz.html">pq_async::timestamp_tz</a> </td></tr>
<tr>
<td>date </td><td>DATEOID </td><td><a class="el" href="classpq__async_1_1date.html">pq_async::date</a> </td></tr>
<tr>
<td>time without time zone </td><td>TIMEOID </td><td><a class="el" href="classpq__async_1_1time.html">pq_async::time</a> </td></tr>
<tr>
<td>time with time zone </td><td>TIMETZOID </td><td><a class="el" href="classpq__async_1_1time__tz.html">pq_async::time_tz</a> </td></tr>
<tr>
<td>interval </td><td>INTERVALOID </td><td><a class="el" href="classpq__async_1_1interval.html">pq_async::interval</a> </td></tr>
</table>
<h3><a class="anchor" id="autotoc_md30"></a>
Geometric types:</h3>
<table class="doxtable">
<tr>
<th>postgres type </th><th>OID </th><th>CPP type  </th></tr>
<tr>
<td>point </td><td>POINTOID </td><td><a class="el" href="classpq__async_1_1point.html">pq_async::point</a> </td></tr>
<tr>
<td>line </td><td>LINEOID </td><td><a class="el" href="classpq__async_1_1line.html">pq_async::line</a> </td></tr>
<tr>
<td>lseg </td><td>LSEGOID </td><td><a class="el" href="classpq__async_1_1lseg.html">pq_async::lseg</a> </td></tr>
<tr>
<td>box </td><td>BOXOID </td><td><a class="el" href="classpq__async_1_1box.html">pq_async::box</a> </td></tr>
<tr>
<td>path closed </td><td>PATHOID </td><td><a class="el" href="classpq__async_1_1path.html">pq_async::path</a> </td></tr>
<tr>
<td>path open </td><td>PATHOID </td><td><a class="el" href="classpq__async_1_1path.html">pq_async::path</a> </td></tr>
<tr>
<td>polygon </td><td>POLYGONOID </td><td><a class="el" href="classpq__async_1_1polygon.html">pq_async::polygon</a> </td></tr>
<tr>
<td>circle </td><td>CIRCLEOID </td><td><a class="el" href="classpq__async_1_1circle.html">pq_async::circle</a> </td></tr>
</table>
<h3><a class="anchor" id="autotoc_md31"></a>
JSON types:</h3>
<table class="doxtable">
<tr>
<th>postgres type </th><th>OID </th><th>CPP type  </th></tr>
<tr>
<td>json </td><td>JSONOID </td><td><a class="el" href="namespacepq__async.html#a11a39262310d63e0b2826fa9d3e70da7">pq_async::json</a> </td></tr>
<tr>
<td>jsonb </td><td>JSONBOID </td><td><a class="el" href="namespacepq__async.html#a11a39262310d63e0b2826fa9d3e70da7">pq_async::json</a> </td></tr>
</table>
<h3><a class="anchor" id="autotoc_md32"></a>
Monetary data types:</h3>
<table class="doxtable">
<tr>
<th>postgres type </th><th>OID </th><th>CPP type  </th></tr>
<tr>
<td>money </td><td>CASHOID </td><td><a class="el" href="classpq__async_1_1money.html">pq_async::money</a> </td></tr>
</table>
<h3><a class="anchor" id="autotoc_md33"></a>
Network types:</h3>
<table class="doxtable">
<tr>
<th>postgres type </th><th>OID </th><th>CPP type  </th></tr>
<tr>
<td>cidr </td><td>CIDROID </td><td><a class="el" href="classpq__async_1_1cidr.html">pq_async::cidr</a> </td></tr>
<tr>
<td>inet </td><td>INETOID </td><td><a class="el" href="classpq__async_1_1inet.html">pq_async::inet</a> </td></tr>
<tr>
<td>macaddr </td><td>MACADDROID </td><td><a class="el" href="classpq__async_1_1macaddr.html">pq_async::macaddr</a> </td></tr>
<tr>
<td>macaddr8 </td><td>MACADDR8OID </td><td><a class="el" href="classpq__async_1_1macaddr8.html">pq_async::macaddr8</a> </td></tr>
</table>
<h3><a class="anchor" id="autotoc_md34"></a>
Numeric types:</h3>
<table class="doxtable">
<tr>
<th>postgres type </th><th>OID </th><th>CPP type  </th></tr>
<tr>
<td>smallint </td><td>INT2OID </td><td>int16_t </td></tr>
<tr>
<td>integer </td><td>INT4OID </td><td>int32_t </td></tr>
<tr>
<td>bigint </td><td>INT8OID </td><td>int64_t </td></tr>
<tr>
<td>numeric </td><td>NUMERICOID </td><td><a class="el" href="classpq__async_1_1numeric.html">pq_async::numeric</a> </td></tr>
<tr>
<td>real </td><td>FLOAT4OID </td><td>float </td></tr>
<tr>
<td>double precision </td><td>FLOAT8OID </td><td>double </td></tr>
</table>
<h3><a class="anchor" id="autotoc_md35"></a>
Range type:</h3>
<table class="doxtable">
<tr>
<th>postgres type </th><th>OID </th><th>CPP type  </th></tr>
<tr>
<td>int4range </td><td>INT4RANGEOID </td><td><a class="el" href="namespacepq__async.html#a4b4c8a2f376d8736b2138e93ce14f37d">pq_async::int4range</a> </td></tr>
<tr>
<td>int8range </td><td>INT8RANGEOID </td><td><a class="el" href="namespacepq__async.html#a2b0c21cc2c74ddf6782a2d7c67a64f1e">pq_async::int8range</a> </td></tr>
<tr>
<td>numrange </td><td>NUMRANGEOID </td><td><a class="el" href="namespacepq__async.html#ae29d617e1ff51f2800848349ab6d6aa5">pq_async::numrange</a> </td></tr>
<tr>
<td>tsrange </td><td>TSRANGEOID </td><td><a class="el" href="namespacepq__async.html#a100bebcb0c0409bb2c20cd159cf3e6e5">pq_async::tsrange</a> </td></tr>
<tr>
<td>tstzrange </td><td>TSTZRANGEOID </td><td><a class="el" href="namespacepq__async.html#a6dd52fd3375d775e54f5e1627eeb9657">pq_async::tstzrange</a> </td></tr>
<tr>
<td>daterange </td><td>DATERANGEOID </td><td><a class="el" href="namespacepq__async.html#af0e065d5d6745ea5cfffef8600c15b84">pq_async::daterange</a> </td></tr>
</table>
<h3><a class="anchor" id="autotoc_md36"></a>
System types:</h3>
<table class="doxtable">
<tr>
<th>postgres type </th><th>OID </th><th>CPP type  </th></tr>
<tr>
<td>oid </td><td>OIDOID </td><td><a class="el" href="classpq__async_1_1oid.html">pq_async::oid</a> </td></tr>
</table>
<h3><a class="anchor" id="autotoc_md37"></a>
UUID type:</h3>
<table class="doxtable">
<tr>
<th>postgres type </th><th>OID </th><th>CPP type  </th></tr>
<tr>
<td>uuid </td><td>UUIDOID </td><td><a class="el" href="classpq__async_1_1uuid.html">pq_async::uuid</a> </td></tr>
</table>
<h1><a class="anchor" id="autotoc_md38"></a>
Unsupported features</h1>
<h2><a class="anchor" id="autotoc_md39"></a>
Asynchronous Large Object</h2>
<p>Async large_object are not supported for the moment.</p>
<h2><a class="anchor" id="autotoc_md40"></a>
Unsupported types</h2>
<p>Note: <b>some of these may be supported in future release</b></p>
<h3><a class="anchor" id="autotoc_md41"></a>
System types:</h3>
<table class="doxtable">
<tr>
<th>postgres type </th><th>OID </th><th>CPP type  </th></tr>
<tr>
<td>tid </td><td>TIDOID </td><td>pq_async::tid </td></tr>
<tr>
<td>xid </td><td>XIDOID </td><td>pq_async::xid </td></tr>
<tr>
<td>cid </td><td>CIDOID </td><td>pq_async::cid </td></tr>
<tr>
<td>char </td><td>CHAROID </td><td>char </td></tr>
<tr>
<td>name </td><td>NAMEOID </td><td>pq_async::name </td></tr>
</table>
<h3><a class="anchor" id="autotoc_md42"></a>
User types:</h3>
<table class="doxtable">
<tr>
<th>postgres type </th><th>OID </th><th>CPP type  </th></tr>
<tr>
<td>enum </td><td>Defined in postgres </td><td>pq_async::enum </td></tr>
<tr>
<td>complex types </td><td>Defined in postgres </td><td>pq_async::complexe </td></tr>
</table>
<h3><a class="anchor" id="autotoc_md43"></a>
Logger:</h3>
<p>TODO: accept a callback on which logging info will be pass.</p>
<h2><a class="anchor" id="autotoc_md44"></a>
Thanks and Credits</h2>
<ul>
<li>PostgreSQL, <a href="https://www.postgresql.org/,">https://www.postgresql.org/,</a> PostgreSQL License</li>
<li>date lib from Howard Hinnant, <a href="https://github.com/HowardHinnant/date,">https://github.com/HowardHinnant/date,</a> MIT license</li>
<li>json lib from Niels Lohmann, <a href="https://github.com/nlohmann/json,">https://github.com/nlohmann/json,</a> MIT license</li>
</ul>
<h2><a class="anchor" id="autotoc_md45"></a>
Known problems</h2>
<ul>
<li>Please note that, because of a bug in the gcc's libstdc++ v6.3, the Howard Hinnant date testit target, can't be build. <br />
 <a href="https://github.com/HowardHinnant/date/issues/340">see that post for more info</a>, <b>Please note that it is not affecting the usage of the library itself, only the tests are affected.</b> </li>
</ul>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Thu Dec 20 2018 11:43:46 for libpq-async++ by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
