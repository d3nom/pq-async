<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>libpq-async++: pq_async::database Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">libpq-async++
   &#160;<span id="projectnumber">0.1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classpq__async_1_1database.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#friends">Friends</a>  </div>
  <div class="headertitle">
<div class="title">pq_async::database Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="database_8h_source.html">src/database.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for pq_async::database:</div>
<div class="dyncontent">
<div class="center"><img src="classpq__async_1_1database__inherit__graph.png" border="0" usemap="#pq__async_1_1database_inherit__map" alt="Inheritance graph"/></div>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for pq_async::database:</div>
<div class="dyncontent">
<div class="center"><img src="classpq__async_1_1database__coll__graph.png" border="0" usemap="#pq__async_1_1database_coll__map" alt="Collaboration graph"/></div>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:af43de96a0cb32e0ea84ebe7dfa814573"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpq__async_1_1database.html#af43de96a0cb32e0ea84ebe7dfa814573">~database</a> ()</td></tr>
<tr class="separator:af43de96a0cb32e0ea84ebe7dfa814573"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad80a834e90da98e0dc9c7d9cbd200615"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacepq__async.html#aabd5df712722ea308c443767392eb42a">sp_event_strand</a>&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpq__async_1_1database.html#ad80a834e90da98e0dc9c7d9cbd200615">get_strand</a> ()</td></tr>
<tr class="separator:ad80a834e90da98e0dc9c7d9cbd200615"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a887fd67d3c7dde55f81ed00e444f2b6f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacepq__async.html#abb00b15e5ba4cb34858e8de109777cbe">sp_connection_lock</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpq__async_1_1database.html#a887fd67d3c7dde55f81ed00e444f2b6f">open_connection</a> (int32_t timeout_ms=5000)</td></tr>
<tr class="memdesc:a887fd67d3c7dde55f81ed00e444f2b6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">synchronously try to acquire and open a connection  <a href="#a887fd67d3c7dde55f81ed00e444f2b6f">More...</a><br /></td></tr>
<tr class="separator:a887fd67d3c7dde55f81ed00e444f2b6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8add67ba6b082ed046013dcb52e2358d"><td class="memTemplParams" colspan="2">template&lt;typename CB , typename std::enable_if&lt; !std::is_array&lt; typename std::remove_pointer&lt; CB &gt;::type &gt;::value &amp;&amp;(std::is_invocable_r&lt; void, typename std::remove_pointer&lt; CB &gt;::type, const cb_error &amp;&gt;::value||std::is_invocable_r&lt; void, typename std::remove_pointer&lt; CB &gt;::type, const cb_error &amp;, sp_connection_lock &gt;::value||std::is_invocable_r&lt; void, typename std::remove_pointer&lt; CB &gt;::type &gt;::value||std::is_invocable_r&lt; void, typename std::remove_pointer&lt; CB &gt;::type, sp_connection_lock &gt;::value), int32_t &gt;::type  = -1&gt; </td></tr>
<tr class="memitem:a8add67ba6b082ed046013dcb52e2358d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpq__async_1_1database.html#a8add67ba6b082ed046013dcb52e2358d">open_connection</a> (const CB &amp;acb, int32_t timeout_ms=5000)</td></tr>
<tr class="memdesc:a8add67ba6b082ed046013dcb52e2358d"><td class="mdescLeft">&#160;</td><td class="mdescRight">asynchronously try to acquire and open a connection  <a href="#a8add67ba6b082ed046013dcb52e2358d">More...</a><br /></td></tr>
<tr class="separator:a8add67ba6b082ed046013dcb52e2358d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef547dc40f9f80b743d8aa83ccd54376"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpq__async_1_1database.html#aef547dc40f9f80b743d8aa83ccd54376">close</a> ()</td></tr>
<tr class="memdesc:aef547dc40f9f80b743d8aa83ccd54376"><td class="mdescLeft">&#160;</td><td class="mdescRight">release the underlying connection this call is always synchronous  <a href="#aef547dc40f9f80b743d8aa83ccd54376">More...</a><br /></td></tr>
<tr class="separator:aef547dc40f9f80b743d8aa83ccd54376"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35e2b15a91190f410df94162f6f0c13b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpq__async_1_1database.html#a35e2b15a91190f410df94162f6f0c13b">working</a> ()</td></tr>
<tr class="memdesc:a35e2b15a91190f410df94162f6f0c13b"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns true if the database is currently working.  <a href="#a35e2b15a91190f410df94162f6f0c13b">More...</a><br /></td></tr>
<tr class="separator:a35e2b15a91190f410df94162f6f0c13b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ba12ad8ec40562af85d896cb5ba2f52"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpq__async_1_1database.html#a6ba12ad8ec40562af85d896cb5ba2f52">in_transaction</a> ()</td></tr>
<tr class="memdesc:a6ba12ad8ec40562af85d896cb5ba2f52"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns if a transaction is in progress  <a href="#a6ba12ad8ec40562af85d896cb5ba2f52">More...</a><br /></td></tr>
<tr class="separator:a6ba12ad8ec40562af85d896cb5ba2f52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82590553a383f5fad5689091f4d59157"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpq__async_1_1database.html#a82590553a383f5fad5689091f4d59157">begin</a> ()</td></tr>
<tr class="memdesc:a82590553a383f5fad5689091f4d59157"><td class="mdescLeft">&#160;</td><td class="mdescRight">synchronously starts a new transaction  <a href="#a82590553a383f5fad5689091f4d59157">More...</a><br /></td></tr>
<tr class="separator:a82590553a383f5fad5689091f4d59157"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5aadcab4c8393227151e85c07851fd19"><td class="memTemplParams" colspan="2">template&lt;typename CB , typename std::enable_if&lt; !std::is_array&lt; typename std::remove_pointer&lt; CB &gt;::type &gt;::value &amp;&amp;(std::is_invocable_r&lt; void, typename std::remove_pointer&lt; CB &gt;::type, const cb_error &amp;&gt;::value||std::is_invocable_r&lt; void, typename std::remove_pointer&lt; CB &gt;::type &gt;::value), int32_t &gt;::type  = -1&gt; </td></tr>
<tr class="memitem:a5aadcab4c8393227151e85c07851fd19"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpq__async_1_1database.html#a5aadcab4c8393227151e85c07851fd19">begin</a> (const CB &amp;acb)</td></tr>
<tr class="memdesc:a5aadcab4c8393227151e85c07851fd19"><td class="mdescLeft">&#160;</td><td class="mdescRight">asynchronously starts a new transaction  <a href="#a5aadcab4c8393227151e85c07851fd19">More...</a><br /></td></tr>
<tr class="separator:a5aadcab4c8393227151e85c07851fd19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72c1dcc03e68d1baef3268a4e0b683de"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpq__async_1_1database.html#a72c1dcc03e68d1baef3268a4e0b683de">commit</a> ()</td></tr>
<tr class="memdesc:a72c1dcc03e68d1baef3268a4e0b683de"><td class="mdescLeft">&#160;</td><td class="mdescRight">synchonously commit current transaction  <a href="#a72c1dcc03e68d1baef3268a4e0b683de">More...</a><br /></td></tr>
<tr class="separator:a72c1dcc03e68d1baef3268a4e0b683de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3faaa9cf9a49e80bd11f21b7257eaa30"><td class="memTemplParams" colspan="2">template&lt;typename CB , typename std::enable_if&lt; !std::is_array&lt; typename std::remove_pointer&lt; CB &gt;::type &gt;::value &amp;&amp;(std::is_invocable_r&lt; void, typename std::remove_pointer&lt; CB &gt;::type, const cb_error &amp;&gt;::value||std::is_invocable_r&lt; void, typename std::remove_pointer&lt; CB &gt;::type &gt;::value), int32_t &gt;::type  = -1&gt; </td></tr>
<tr class="memitem:a3faaa9cf9a49e80bd11f21b7257eaa30"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpq__async_1_1database.html#a3faaa9cf9a49e80bd11f21b7257eaa30">commit</a> (const CB &amp;acb)</td></tr>
<tr class="memdesc:a3faaa9cf9a49e80bd11f21b7257eaa30"><td class="mdescLeft">&#160;</td><td class="mdescRight">asynchonously commit current transaction  <a href="#a3faaa9cf9a49e80bd11f21b7257eaa30">More...</a><br /></td></tr>
<tr class="separator:a3faaa9cf9a49e80bd11f21b7257eaa30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b71c15239af2889c8697a805cf6bd86"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpq__async_1_1database.html#a9b71c15239af2889c8697a805cf6bd86">rollback</a> ()</td></tr>
<tr class="memdesc:a9b71c15239af2889c8697a805cf6bd86"><td class="mdescLeft">&#160;</td><td class="mdescRight">synchonously rollback current transaction  <a href="#a9b71c15239af2889c8697a805cf6bd86">More...</a><br /></td></tr>
<tr class="separator:a9b71c15239af2889c8697a805cf6bd86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ac85db4dec7a56ad44309bc18f02670"><td class="memTemplParams" colspan="2">template&lt;typename CB , typename std::enable_if&lt; !std::is_array&lt; typename std::remove_pointer&lt; CB &gt;::type &gt;::value &amp;&amp;(std::is_invocable_r&lt; void, typename std::remove_pointer&lt; CB &gt;::type, const cb_error &amp;&gt;::value||std::is_invocable_r&lt; void, typename std::remove_pointer&lt; CB &gt;::type &gt;::value), int32_t &gt;::type  = -1&gt; </td></tr>
<tr class="memitem:a5ac85db4dec7a56ad44309bc18f02670"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpq__async_1_1database.html#a5ac85db4dec7a56ad44309bc18f02670">roollback</a> (const CB &amp;acb)</td></tr>
<tr class="memdesc:a5ac85db4dec7a56ad44309bc18f02670"><td class="mdescLeft">&#160;</td><td class="mdescRight">asynchonously rollback current transaction  <a href="#a5ac85db4dec7a56ad44309bc18f02670">More...</a><br /></td></tr>
<tr class="separator:a5ac85db4dec7a56ad44309bc18f02670"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92dc82644347b9bdc081768f80e372f5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpq__async_1_1database.html#a92dc82644347b9bdc081768f80e372f5">set_savepoint</a> (const char *name)</td></tr>
<tr class="memdesc:a92dc82644347b9bdc081768f80e372f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">synchronously sets a new savepoint inside the current transaction  <a href="#a92dc82644347b9bdc081768f80e372f5">More...</a><br /></td></tr>
<tr class="separator:a92dc82644347b9bdc081768f80e372f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb121211b73fffdb837881a04361c830"><td class="memTemplParams" colspan="2">template&lt;typename CB , typename std::enable_if&lt; !std::is_array&lt; typename std::remove_pointer&lt; CB &gt;::type &gt;::value &amp;&amp;(std::is_invocable_r&lt; void, typename std::remove_pointer&lt; CB &gt;::type, const cb_error &amp;&gt;::value||std::is_invocable_r&lt; void, typename std::remove_pointer&lt; CB &gt;::type &gt;::value), int32_t &gt;::type  = -1&gt; </td></tr>
<tr class="memitem:acb121211b73fffdb837881a04361c830"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpq__async_1_1database.html#acb121211b73fffdb837881a04361c830">set_savepoint</a> (const CB &amp;acb, const char *name)</td></tr>
<tr class="memdesc:acb121211b73fffdb837881a04361c830"><td class="mdescLeft">&#160;</td><td class="mdescRight">asynchronously sets a new savepoint inside the current transaction  <a href="#acb121211b73fffdb837881a04361c830">More...</a><br /></td></tr>
<tr class="separator:acb121211b73fffdb837881a04361c830"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a41daa5b5b2dec092e3bdde8c3d6500"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpq__async_1_1database.html#a4a41daa5b5b2dec092e3bdde8c3d6500">release_savepoint</a> (const char *name)</td></tr>
<tr class="memdesc:a4a41daa5b5b2dec092e3bdde8c3d6500"><td class="mdescLeft">&#160;</td><td class="mdescRight">synchonously release the specified savepoint  <a href="#a4a41daa5b5b2dec092e3bdde8c3d6500">More...</a><br /></td></tr>
<tr class="separator:a4a41daa5b5b2dec092e3bdde8c3d6500"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c602c9c427368e0d11fdc585bab9da5"><td class="memTemplParams" colspan="2">template&lt;typename CB , typename std::enable_if&lt; !std::is_array&lt; typename std::remove_pointer&lt; CB &gt;::type &gt;::value &amp;&amp;(std::is_invocable_r&lt; void, typename std::remove_pointer&lt; CB &gt;::type, const cb_error &amp;&gt;::value||std::is_invocable_r&lt; void, typename std::remove_pointer&lt; CB &gt;::type &gt;::value), int32_t &gt;::type  = -1&gt; </td></tr>
<tr class="memitem:a9c602c9c427368e0d11fdc585bab9da5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpq__async_1_1database.html#a9c602c9c427368e0d11fdc585bab9da5">release_savepoint</a> (const CB &amp;acb, const char *name)</td></tr>
<tr class="memdesc:a9c602c9c427368e0d11fdc585bab9da5"><td class="mdescLeft">&#160;</td><td class="mdescRight">asynchonously release the specified savepoint  <a href="#a9c602c9c427368e0d11fdc585bab9da5">More...</a><br /></td></tr>
<tr class="separator:a9c602c9c427368e0d11fdc585bab9da5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f48ccb20299b05f703976a477692a29"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpq__async_1_1database.html#a6f48ccb20299b05f703976a477692a29">rollback_savepoint</a> (const char *name)</td></tr>
<tr class="memdesc:a6f48ccb20299b05f703976a477692a29"><td class="mdescLeft">&#160;</td><td class="mdescRight">synchonously rollback the specified savepoint  <a href="#a6f48ccb20299b05f703976a477692a29">More...</a><br /></td></tr>
<tr class="separator:a6f48ccb20299b05f703976a477692a29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab347754cd442aa93a1cd6201036c49c5"><td class="memTemplParams" colspan="2">template&lt;typename CB , typename std::enable_if&lt; !std::is_array&lt; typename std::remove_pointer&lt; CB &gt;::type &gt;::value &amp;&amp;(std::is_invocable_r&lt; void, typename std::remove_pointer&lt; CB &gt;::type, const cb_error &amp;&gt;::value||std::is_invocable_r&lt; void, typename std::remove_pointer&lt; CB &gt;::type &gt;::value), int32_t &gt;::type  = -1&gt; </td></tr>
<tr class="memitem:ab347754cd442aa93a1cd6201036c49c5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpq__async_1_1database.html#ab347754cd442aa93a1cd6201036c49c5">rollback_savepoint</a> (const CB &amp;acb, const char *name)</td></tr>
<tr class="memdesc:ab347754cd442aa93a1cd6201036c49c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">asynchonously rollback the specified savepoint  <a href="#ab347754cd442aa93a1cd6201036c49c5">More...</a><br /></td></tr>
<tr class="separator:ab347754cd442aa93a1cd6201036c49c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fd6245f84aa5051a88cba192608b9d2"><td class="memTemplParams" colspan="2">template&lt;typename... PARAMS, typename std::enable_if&lt; !std::is_same&lt; int, typename std::remove_pointer&lt; typename select_last&lt; PARAMS... &gt;::type &gt;::type &gt;::value &amp;&amp;!std::is_array&lt; typename std::remove_pointer&lt; typename select_last&lt; PARAMS... &gt;::type &gt;::type &gt;::value &amp;&amp;(std::is_invocable_r&lt; void, typename std::remove_pointer&lt; typename select_last&lt; PARAMS... &gt;::type &gt;::type, const cb_error &amp;&gt;::value||std::is_invocable_r&lt; void, typename std::remove_pointer&lt; typename select_last&lt; PARAMS... &gt;::type &gt;::type, const cb_error &amp;, int &gt;::value||std::is_invocable_r&lt; void, typename std::remove_pointer&lt; typename select_last&lt; PARAMS... &gt;::type &gt;::type &gt;::value||std::is_invocable_r&lt; void, typename std::remove_pointer&lt; typename select_last&lt; PARAMS... &gt;::type &gt;::type, int &gt;::value), int32_t &gt;::type  = -1&gt; </td></tr>
<tr class="memitem:a9fd6245f84aa5051a88cba192608b9d2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpq__async_1_1database.html#a9fd6245f84aa5051a88cba192608b9d2">execute</a> (const char *sql, const PARAMS &amp;... args)</td></tr>
<tr class="memdesc:a9fd6245f84aa5051a88cba192608b9d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">asynchrounously process a query and returns the number of rows affected by insert, update and delete  <a href="#a9fd6245f84aa5051a88cba192608b9d2">More...</a><br /></td></tr>
<tr class="separator:a9fd6245f84aa5051a88cba192608b9d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9635cb56a1dec676fc6e858523977bfa"><td class="memTemplParams" colspan="2">template&lt;typename T , typename std::enable_if&lt; !std::is_array&lt; typename std::remove_pointer&lt; T &gt;::type &gt;::value &amp;&amp;(std::is_invocable_r&lt; void, typename std::remove_pointer&lt; T &gt;::type, const cb_error &amp;&gt;::value||std::is_invocable_r&lt; void, typename std::remove_pointer&lt; T &gt;::type, const cb_error &amp;, int &gt;::value||std::is_invocable_r&lt; void, typename std::remove_pointer&lt; T &gt;::type &gt;::value||std::is_invocable_r&lt; void, typename std::remove_pointer&lt; T &gt;::type, int &gt;::value), int32_t &gt;::type  = -1&gt; </td></tr>
<tr class="memitem:a9635cb56a1dec676fc6e858523977bfa"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpq__async_1_1database.html#a9635cb56a1dec676fc6e858523977bfa">execute</a> (const char *sql, const <a class="el" href="classpq__async_1_1parameters.html">parameters</a> &amp;p, const T &amp;acb)</td></tr>
<tr class="memdesc:a9635cb56a1dec676fc6e858523977bfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">asynchrounously process a query and returns the number of rows affected by insert, update and delete  <a href="#a9635cb56a1dec676fc6e858523977bfa">More...</a><br /></td></tr>
<tr class="separator:a9635cb56a1dec676fc6e858523977bfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae28a4bcb1a9178e91880254ae161b8d6"><td class="memTemplParams" colspan="2">template&lt;typename... PARAMS, typename std::enable_if&lt; std::is_same&lt; int, typename std::remove_pointer&lt; typename select_last&lt; PARAMS... &gt;::type &gt;::type &gt;::value||std::is_array&lt; typename std::remove_pointer&lt; typename select_last&lt; PARAMS... &gt;::type &gt;::type &gt;::value||(!std::is_invocable_r&lt; void, typename std::remove_pointer&lt; typename select_last&lt; PARAMS... &gt;::type &gt;::type, const cb_error &amp;&gt;::value &amp;&amp;!std::is_invocable_r&lt; void, typename std::remove_pointer&lt; typename select_last&lt; PARAMS... &gt;::type &gt;::type, const cb_error &amp;, int &gt;::value &amp;&amp;!std::is_invocable_r&lt; void, typename std::remove_pointer&lt; typename select_last&lt; PARAMS... &gt;::type &gt;::type &gt;::value &amp;&amp;!std::is_invocable_r&lt; void, typename std::remove_pointer&lt; typename select_last&lt; PARAMS... &gt;::type &gt;::type, int &gt;::value), int32_t &gt;::type  = -1&gt; </td></tr>
<tr class="memitem:ae28a4bcb1a9178e91880254ae161b8d6"><td class="memTemplItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpq__async_1_1database.html#ae28a4bcb1a9178e91880254ae161b8d6">execute</a> (const char *sql, const PARAMS &amp;... args)</td></tr>
<tr class="memdesc:ae28a4bcb1a9178e91880254ae161b8d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">synchrounously process a query and returns the number of rows affected by insert, update and delete  <a href="#ae28a4bcb1a9178e91880254ae161b8d6">More...</a><br /></td></tr>
<tr class="separator:ae28a4bcb1a9178e91880254ae161b8d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a613cd93dcb688e1f199083c07ec8ea5e"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpq__async_1_1database.html#a613cd93dcb688e1f199083c07ec8ea5e">execute</a> (const char *sql)</td></tr>
<tr class="memdesc:a613cd93dcb688e1f199083c07ec8ea5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">synchrounously process a query and returns the number of rows affected by insert, update and delete  <a href="#a613cd93dcb688e1f199083c07ec8ea5e">More...</a><br /></td></tr>
<tr class="separator:a613cd93dcb688e1f199083c07ec8ea5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf61f88a03a8b8d97361d13aab594af3"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpq__async_1_1database.html#acf61f88a03a8b8d97361d13aab594af3">execute</a> (const char *sql, const <a class="el" href="classpq__async_1_1parameters.html">parameters</a> &amp;p)</td></tr>
<tr class="memdesc:acf61f88a03a8b8d97361d13aab594af3"><td class="mdescLeft">&#160;</td><td class="mdescRight">synchrounously process a query and returns the number of rows affected by insert, update and delete  <a href="#acf61f88a03a8b8d97361d13aab594af3">More...</a><br /></td></tr>
<tr class="separator:acf61f88a03a8b8d97361d13aab594af3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a074d2edf72459f64fa9ab85ec58c4714"><td class="memTemplParams" colspan="2">template&lt;typename... PARAMS, typename std::enable_if&lt; !std::is_same&lt; sp_data_table, typename std::remove_pointer&lt; typename select_last&lt; PARAMS... &gt;::type &gt;::type &gt;::value &amp;&amp;!std::is_array&lt; typename std::remove_pointer&lt; typename select_last&lt; PARAMS... &gt;::type &gt;::type &gt;::value &amp;&amp;(std::is_invocable_r&lt; void, typename std::remove_pointer&lt; typename select_last&lt; PARAMS... &gt;::type &gt;::type, const cb_error &amp;&gt;::value||std::is_invocable_r&lt; void, typename std::remove_pointer&lt; typename select_last&lt; PARAMS... &gt;::type &gt;::type, const cb_error &amp;, sp_data_table &gt;::value||std::is_invocable_r&lt; void, typename std::remove_pointer&lt; typename select_last&lt; PARAMS... &gt;::type &gt;::type &gt;::value||std::is_invocable_r&lt; void, typename std::remove_pointer&lt; typename select_last&lt; PARAMS... &gt;::type &gt;::type, sp_data_table &gt;::value), int32_t &gt;::type  = -1&gt; </td></tr>
<tr class="memitem:a074d2edf72459f64fa9ab85ec58c4714"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpq__async_1_1database.html#a074d2edf72459f64fa9ab85ec58c4714">query</a> (const char *sql, const PARAMS &amp;... args)</td></tr>
<tr class="memdesc:a074d2edf72459f64fa9ab85ec58c4714"><td class="mdescLeft">&#160;</td><td class="mdescRight">asynchrounously process a query and returns a <a class="el" href="classpq__async_1_1data__table.html">pq_async::data_table</a> as the result  <a href="#a074d2edf72459f64fa9ab85ec58c4714">More...</a><br /></td></tr>
<tr class="separator:a074d2edf72459f64fa9ab85ec58c4714"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7432fbc488a3f489f0a462f4fd3f8acc"><td class="memTemplParams" colspan="2">template&lt;typename T , typename std::enable_if&lt; !std::is_array&lt; typename std::remove_pointer&lt; T &gt;::type &gt;::value &amp;&amp;(std::is_invocable_r&lt; void, typename std::remove_pointer&lt; T &gt;::type, const cb_error &amp;&gt;::value||std::is_invocable_r&lt; void, typename std::remove_pointer&lt; T &gt;::type, const cb_error &amp;, sp_data_table &gt;::value||std::is_invocable_r&lt; void, typename std::remove_pointer&lt; T &gt;::type &gt;::value||std::is_invocable_r&lt; void, typename std::remove_pointer&lt; T &gt;::type, sp_data_table &gt;::value), int32_t &gt;::type  = -1&gt; </td></tr>
<tr class="memitem:a7432fbc488a3f489f0a462f4fd3f8acc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpq__async_1_1database.html#a7432fbc488a3f489f0a462f4fd3f8acc">query</a> (const char *sql, const <a class="el" href="classpq__async_1_1parameters.html">parameters</a> &amp;p, const T &amp;acb)</td></tr>
<tr class="memdesc:a7432fbc488a3f489f0a462f4fd3f8acc"><td class="mdescLeft">&#160;</td><td class="mdescRight">asynchrounously process a query and returns a <a class="el" href="classpq__async_1_1data__table.html">pq_async::data_table</a> as the result  <a href="#a7432fbc488a3f489f0a462f4fd3f8acc">More...</a><br /></td></tr>
<tr class="separator:a7432fbc488a3f489f0a462f4fd3f8acc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76c49b45b48515b4f2d16add7f478584"><td class="memTemplParams" colspan="2">template&lt;typename... PARAMS, typename std::enable_if&lt; std::is_same&lt; sp_data_table, typename std::remove_pointer&lt; typename select_last&lt; PARAMS... &gt;::type &gt;::type &gt;::value||std::is_array&lt; typename std::remove_pointer&lt; typename select_last&lt; PARAMS... &gt;::type &gt;::type &gt;::value||(!std::is_invocable_r&lt; void, typename std::remove_pointer&lt; typename select_last&lt; PARAMS... &gt;::type &gt;::type, const cb_error &amp;&gt;::value &amp;&amp;!std::is_invocable_r&lt; void, typename std::remove_pointer&lt; typename select_last&lt; PARAMS... &gt;::type &gt;::type, const cb_error &amp;, sp_data_table &gt;::value &amp;&amp;!std::is_invocable_r&lt; void, typename std::remove_pointer&lt; typename select_last&lt; PARAMS... &gt;::type &gt;::type &gt;::value &amp;&amp;!std::is_invocable_r&lt; void, typename std::remove_pointer&lt; typename select_last&lt; PARAMS... &gt;::type &gt;::type, sp_data_table &gt;::value), int32_t &gt;::type  = -1&gt; </td></tr>
<tr class="memitem:a76c49b45b48515b4f2d16add7f478584"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacepq__async.html#ac55315e08f6f76bc2dfb7f0cf3b27073">sp_data_table</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpq__async_1_1database.html#a76c49b45b48515b4f2d16add7f478584">query</a> (const char *sql, const PARAMS &amp;... args)</td></tr>
<tr class="memdesc:a76c49b45b48515b4f2d16add7f478584"><td class="mdescLeft">&#160;</td><td class="mdescRight">synchrounously process a query and returns a <a class="el" href="classpq__async_1_1data__table.html">pq_async::data_table</a> as the result  <a href="#a76c49b45b48515b4f2d16add7f478584">More...</a><br /></td></tr>
<tr class="separator:a76c49b45b48515b4f2d16add7f478584"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1835e3bbfd66af6041f93cb740b24da"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacepq__async.html#ac55315e08f6f76bc2dfb7f0cf3b27073">sp_data_table</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpq__async_1_1database.html#ac1835e3bbfd66af6041f93cb740b24da">query</a> (const char *sql)</td></tr>
<tr class="memdesc:ac1835e3bbfd66af6041f93cb740b24da"><td class="mdescLeft">&#160;</td><td class="mdescRight">synchrounously process a query and returns a <a class="el" href="classpq__async_1_1data__table.html">pq_async::data_table</a> as the result  <a href="#ac1835e3bbfd66af6041f93cb740b24da">More...</a><br /></td></tr>
<tr class="separator:ac1835e3bbfd66af6041f93cb740b24da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03d9639786149f61cacc7de62af28f4c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacepq__async.html#ac55315e08f6f76bc2dfb7f0cf3b27073">sp_data_table</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpq__async_1_1database.html#a03d9639786149f61cacc7de62af28f4c">query</a> (const char *sql, const <a class="el" href="classpq__async_1_1parameters.html">parameters</a> &amp;p)</td></tr>
<tr class="memdesc:a03d9639786149f61cacc7de62af28f4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">synchrounously process a query and returns a <a class="el" href="classpq__async_1_1data__table.html">pq_async::data_table</a> as the result  <a href="#a03d9639786149f61cacc7de62af28f4c">More...</a><br /></td></tr>
<tr class="separator:a03d9639786149f61cacc7de62af28f4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a1cc72e1ecc5af712a79c15770c0a39"><td class="memTemplParams" colspan="2">template&lt;typename... PARAMS, typename std::enable_if&lt; !std::is_same&lt; sp_data_row, typename std::remove_pointer&lt; typename select_last&lt; PARAMS... &gt;::type &gt;::type &gt;::value &amp;&amp;!std::is_array&lt; typename std::remove_pointer&lt; typename select_last&lt; PARAMS... &gt;::type &gt;::type &gt;::value &amp;&amp;(std::is_invocable_r&lt; void, typename std::remove_pointer&lt; typename select_last&lt; PARAMS... &gt;::type &gt;::type, const cb_error &amp;&gt;::value||std::is_invocable_r&lt; void, typename std::remove_pointer&lt; typename select_last&lt; PARAMS... &gt;::type &gt;::type, const cb_error &amp;, sp_data_row &gt;::value||std::is_invocable_r&lt; void, typename std::remove_pointer&lt; typename select_last&lt; PARAMS... &gt;::type &gt;::type &gt;::value||std::is_invocable_r&lt; void, typename std::remove_pointer&lt; typename select_last&lt; PARAMS... &gt;::type &gt;::type, sp_data_row &gt;::value), int32_t &gt;::type  = -1&gt; </td></tr>
<tr class="memitem:a1a1cc72e1ecc5af712a79c15770c0a39"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpq__async_1_1database.html#a1a1cc72e1ecc5af712a79c15770c0a39">query_single</a> (const char *sql, const PARAMS &amp;... args)</td></tr>
<tr class="memdesc:a1a1cc72e1ecc5af712a79c15770c0a39"><td class="mdescLeft">&#160;</td><td class="mdescRight">asynchrounously process a query and returns a <a class="el" href="classpq__async_1_1data__row.html">pq_async::data_row</a> as the result  <a href="#a1a1cc72e1ecc5af712a79c15770c0a39">More...</a><br /></td></tr>
<tr class="separator:a1a1cc72e1ecc5af712a79c15770c0a39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5e352b399af7bc4b62bf79b42ae10c7"><td class="memTemplParams" colspan="2">template&lt;typename T , typename std::enable_if&lt; !std::is_array&lt; typename std::remove_pointer&lt; T &gt;::type &gt;::value &amp;&amp;(std::is_invocable_r&lt; void, typename std::remove_pointer&lt; T &gt;::type, const cb_error &amp;&gt;::value||std::is_invocable_r&lt; void, typename std::remove_pointer&lt; T &gt;::type, const cb_error &amp;, sp_data_row &gt;::value||std::is_invocable_r&lt; void, typename std::remove_pointer&lt; T &gt;::type &gt;::value||std::is_invocable_r&lt; void, typename std::remove_pointer&lt; T &gt;::type, sp_data_row &gt;::value), int32_t &gt;::type  = -1&gt; </td></tr>
<tr class="memitem:ab5e352b399af7bc4b62bf79b42ae10c7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpq__async_1_1database.html#ab5e352b399af7bc4b62bf79b42ae10c7">query_single</a> (const char *sql, const <a class="el" href="classpq__async_1_1parameters.html">parameters</a> &amp;p, const T &amp;acb)</td></tr>
<tr class="memdesc:ab5e352b399af7bc4b62bf79b42ae10c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">asynchrounously process a query and returns a <a class="el" href="classpq__async_1_1data__row.html">pq_async::data_row</a> as the result  <a href="#ab5e352b399af7bc4b62bf79b42ae10c7">More...</a><br /></td></tr>
<tr class="separator:ab5e352b399af7bc4b62bf79b42ae10c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a826d8cee3bc6f902b8e8341e9e281f85"><td class="memTemplParams" colspan="2">template&lt;typename... PARAMS, typename std::enable_if&lt; std::is_same&lt; sp_data_row, typename std::remove_pointer&lt; typename select_last&lt; PARAMS... &gt;::type &gt;::type &gt;::value||std::is_array&lt; typename std::remove_pointer&lt; typename select_last&lt; PARAMS... &gt;::type &gt;::type &gt;::value||(!std::is_invocable_r&lt; void, typename std::remove_pointer&lt; typename select_last&lt; PARAMS... &gt;::type &gt;::type, const cb_error &amp;&gt;::value &amp;&amp;!std::is_invocable_r&lt; void, typename std::remove_pointer&lt; typename select_last&lt; PARAMS... &gt;::type &gt;::type, const cb_error &amp;, sp_data_row &gt;::value &amp;&amp;!std::is_invocable_r&lt; void, typename std::remove_pointer&lt; typename select_last&lt; PARAMS... &gt;::type &gt;::type &gt;::value &amp;&amp;!std::is_invocable_r&lt; void, typename std::remove_pointer&lt; typename select_last&lt; PARAMS... &gt;::type &gt;::type, sp_data_row &gt;::value), int32_t &gt;::type  = -1&gt; </td></tr>
<tr class="memitem:a826d8cee3bc6f902b8e8341e9e281f85"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacepq__async.html#a496df213d664fd4fbc3835f2db9dd5ea">sp_data_row</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpq__async_1_1database.html#a826d8cee3bc6f902b8e8341e9e281f85">query_single</a> (const char *sql, const PARAMS &amp;... args)</td></tr>
<tr class="memdesc:a826d8cee3bc6f902b8e8341e9e281f85"><td class="mdescLeft">&#160;</td><td class="mdescRight">synchrounously process a query and returns a <a class="el" href="classpq__async_1_1data__row.html">pq_async::data_row</a> as the result  <a href="#a826d8cee3bc6f902b8e8341e9e281f85">More...</a><br /></td></tr>
<tr class="separator:a826d8cee3bc6f902b8e8341e9e281f85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af30193b4e5ac17af590341e77047290c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacepq__async.html#a496df213d664fd4fbc3835f2db9dd5ea">sp_data_row</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpq__async_1_1database.html#af30193b4e5ac17af590341e77047290c">query_single</a> (const char *sql)</td></tr>
<tr class="memdesc:af30193b4e5ac17af590341e77047290c"><td class="mdescLeft">&#160;</td><td class="mdescRight">synchrounously process a query and returns a <a class="el" href="classpq__async_1_1data__row.html">pq_async::data_row</a> as the result  <a href="#af30193b4e5ac17af590341e77047290c">More...</a><br /></td></tr>
<tr class="separator:af30193b4e5ac17af590341e77047290c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40153102f9a6e31ffc3e2e0b46a7f576"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacepq__async.html#a496df213d664fd4fbc3835f2db9dd5ea">sp_data_row</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpq__async_1_1database.html#a40153102f9a6e31ffc3e2e0b46a7f576">query_single</a> (const char *sql, const <a class="el" href="classpq__async_1_1parameters.html">parameters</a> &amp;p)</td></tr>
<tr class="memdesc:a40153102f9a6e31ffc3e2e0b46a7f576"><td class="mdescLeft">&#160;</td><td class="mdescRight">synchrounously process a query and returns a <a class="el" href="classpq__async_1_1data__row.html">pq_async::data_row</a> as the result  <a href="#a40153102f9a6e31ffc3e2e0b46a7f576">More...</a><br /></td></tr>
<tr class="separator:a40153102f9a6e31ffc3e2e0b46a7f576"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a453a701d0471cc919e2c0bd411f1e990"><td class="memTemplParams" colspan="2">template&lt;typename R , typename... PARAMS, typename std::enable_if&lt; !std::is_same&lt; R, typename std::remove_pointer&lt; typename select_last&lt; PARAMS... &gt;::type &gt;::type &gt;::value &amp;&amp;!std::is_array&lt; typename std::remove_pointer&lt; typename select_last&lt; PARAMS... &gt;::type &gt;::type &gt;::value &amp;&amp;(std::is_invocable_r&lt; void, typename std::remove_pointer&lt; typename select_last&lt; PARAMS... &gt;::type &gt;::type, const cb_error &amp;&gt;::value||std::is_invocable_r&lt; void, typename std::remove_pointer&lt; typename select_last&lt; PARAMS... &gt;::type &gt;::type, const cb_error &amp;, R &gt;::value||std::is_invocable_r&lt; void, typename std::remove_pointer&lt; typename select_last&lt; PARAMS... &gt;::type &gt;::type &gt;::value||std::is_invocable_r&lt; void, typename std::remove_pointer&lt; typename select_last&lt; PARAMS... &gt;::type &gt;::type, R &gt;::value), int32_t &gt;::type  = -1&gt; </td></tr>
<tr class="memitem:a453a701d0471cc919e2c0bd411f1e990"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpq__async_1_1database.html#a453a701d0471cc919e2c0bd411f1e990">query_value</a> (const char *sql, const PARAMS &amp;... args)</td></tr>
<tr class="memdesc:a453a701d0471cc919e2c0bd411f1e990"><td class="mdescLeft">&#160;</td><td class="mdescRight">asynchrounously process a query and returns a scalar value as the result  <a href="#a453a701d0471cc919e2c0bd411f1e990">More...</a><br /></td></tr>
<tr class="separator:a453a701d0471cc919e2c0bd411f1e990"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd127e1c68dbdcb389bd647b5b228936"><td class="memTemplParams" colspan="2">template&lt;typename R , typename T , typename std::enable_if&lt; !std::is_array&lt; typename std::remove_pointer&lt; T &gt;::type &gt;::value &amp;&amp;(std::is_invocable_r&lt; void, typename std::remove_pointer&lt; T &gt;::type, const cb_error &amp;&gt;::value||std::is_invocable_r&lt; void, typename std::remove_pointer&lt; T &gt;::type, const cb_error &amp;, R &gt;::value||std::is_invocable_r&lt; void, typename std::remove_pointer&lt; T &gt;::type &gt;::value||std::is_invocable_r&lt; void, typename std::remove_pointer&lt; T &gt;::type, R &gt;::value), int32_t &gt;::type  = -1&gt; </td></tr>
<tr class="memitem:abd127e1c68dbdcb389bd647b5b228936"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpq__async_1_1database.html#abd127e1c68dbdcb389bd647b5b228936">query_value</a> (const char *sql, const <a class="el" href="classpq__async_1_1parameters.html">parameters</a> &amp;p, const T &amp;acb)</td></tr>
<tr class="memdesc:abd127e1c68dbdcb389bd647b5b228936"><td class="mdescLeft">&#160;</td><td class="mdescRight">asynchrounously process a query and returns a scalar value as the result  <a href="#abd127e1c68dbdcb389bd647b5b228936">More...</a><br /></td></tr>
<tr class="separator:abd127e1c68dbdcb389bd647b5b228936"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa21ab335761fe0f00f2c551ffb33721f"><td class="memTemplParams" colspan="2">template&lt;typename R , typename... PARAMS, typename std::enable_if&lt; std::is_same&lt; R, typename std::remove_pointer&lt; typename select_last&lt; PARAMS... &gt;::type &gt;::type &gt;::value||std::is_array&lt; typename std::remove_pointer&lt; typename select_last&lt; PARAMS... &gt;::type &gt;::type &gt;::value||(!std::is_invocable_r&lt; void, typename std::remove_pointer&lt; typename select_last&lt; PARAMS... &gt;::type &gt;::type, const cb_error &amp;&gt;::value &amp;&amp;!std::is_invocable_r&lt; void, typename std::remove_pointer&lt; typename select_last&lt; PARAMS... &gt;::type &gt;::type, const cb_error &amp;, R &gt;::value &amp;&amp;!std::is_invocable_r&lt; void, typename std::remove_pointer&lt; typename select_last&lt; PARAMS... &gt;::type &gt;::type &gt;::value &amp;&amp;!std::is_invocable_r&lt; void, typename std::remove_pointer&lt; typename select_last&lt; PARAMS... &gt;::type &gt;::type, R &gt;::value), int32_t &gt;::type  = -1&gt; </td></tr>
<tr class="memitem:aa21ab335761fe0f00f2c551ffb33721f"><td class="memTemplItemLeft" align="right" valign="top">R&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpq__async_1_1database.html#aa21ab335761fe0f00f2c551ffb33721f">query_value</a> (const char *sql, const PARAMS &amp;... args)</td></tr>
<tr class="memdesc:aa21ab335761fe0f00f2c551ffb33721f"><td class="mdescLeft">&#160;</td><td class="mdescRight">synchrounously process a query and returns a scalar value as the result  <a href="#aa21ab335761fe0f00f2c551ffb33721f">More...</a><br /></td></tr>
<tr class="separator:aa21ab335761fe0f00f2c551ffb33721f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b0f04f7a80942f1e0cdbdbdb6c816a0"><td class="memTemplParams" colspan="2">template&lt;typename R &gt; </td></tr>
<tr class="memitem:a6b0f04f7a80942f1e0cdbdbdb6c816a0"><td class="memTemplItemLeft" align="right" valign="top">R&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpq__async_1_1database.html#a6b0f04f7a80942f1e0cdbdbdb6c816a0">query_value</a> (const char *sql)</td></tr>
<tr class="memdesc:a6b0f04f7a80942f1e0cdbdbdb6c816a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">synchrounously process a query and returns a scalar value as the result  <a href="#a6b0f04f7a80942f1e0cdbdbdb6c816a0">More...</a><br /></td></tr>
<tr class="separator:a6b0f04f7a80942f1e0cdbdbdb6c816a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfff557ed62272313820e52aa8f9777f"><td class="memTemplParams" colspan="2">template&lt;typename R &gt; </td></tr>
<tr class="memitem:adfff557ed62272313820e52aa8f9777f"><td class="memTemplItemLeft" align="right" valign="top">R&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpq__async_1_1database.html#adfff557ed62272313820e52aa8f9777f">query_value</a> (const char *sql, const <a class="el" href="classpq__async_1_1parameters.html">parameters</a> &amp;p)</td></tr>
<tr class="memdesc:adfff557ed62272313820e52aa8f9777f"><td class="mdescLeft">&#160;</td><td class="mdescRight">synchrounously process a query and returns a scalar value as the result  <a href="#adfff557ed62272313820e52aa8f9777f">More...</a><br /></td></tr>
<tr class="separator:adfff557ed62272313820e52aa8f9777f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7daa2da6f901e99311da698a29f9ce71"><td class="memTemplParams" colspan="2">template&lt;typename... PARAMS, typename std::enable_if&lt; !std::is_same&lt; sp_data_reader, typename std::remove_pointer&lt; typename select_last&lt; PARAMS... &gt;::type &gt;::type &gt;::value &amp;&amp;!std::is_array&lt; typename std::remove_pointer&lt; typename select_last&lt; PARAMS... &gt;::type &gt;::type &gt;::value &amp;&amp;(std::is_invocable_r&lt; void, typename std::remove_pointer&lt; typename select_last&lt; PARAMS... &gt;::type &gt;::type, const cb_error &amp;&gt;::value||std::is_invocable_r&lt; void, typename std::remove_pointer&lt; typename select_last&lt; PARAMS... &gt;::type &gt;::type, const cb_error &amp;, sp_data_reader &gt;::value||std::is_invocable_r&lt; void, typename std::remove_pointer&lt; typename select_last&lt; PARAMS... &gt;::type &gt;::type &gt;::value||std::is_invocable_r&lt; void, typename std::remove_pointer&lt; typename select_last&lt; PARAMS... &gt;::type &gt;::type, sp_data_reader &gt;::value), int32_t &gt;::type  = -1&gt; </td></tr>
<tr class="memitem:a7daa2da6f901e99311da698a29f9ce71"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpq__async_1_1database.html#a7daa2da6f901e99311da698a29f9ce71">query_reader</a> (const char *sql, const PARAMS &amp;... args)</td></tr>
<tr class="memdesc:a7daa2da6f901e99311da698a29f9ce71"><td class="mdescLeft">&#160;</td><td class="mdescRight">asynchrounously process a query and returns a <a class="el" href="classpq__async_1_1data__reader.html">pq_async::data_reader</a> as the result  <a href="#a7daa2da6f901e99311da698a29f9ce71">More...</a><br /></td></tr>
<tr class="separator:a7daa2da6f901e99311da698a29f9ce71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa20c3a797bfe97ac855bfc495f18c15d"><td class="memTemplParams" colspan="2">template&lt;typename T , typename std::enable_if&lt; !std::is_array&lt; typename std::remove_pointer&lt; T &gt;::type &gt;::value &amp;&amp;(std::is_invocable_r&lt; void, typename std::remove_pointer&lt; T &gt;::type, const cb_error &amp;&gt;::value||std::is_invocable_r&lt; void, typename std::remove_pointer&lt; T &gt;::type, const cb_error &amp;, sp_data_reader &gt;::value||std::is_invocable_r&lt; void, typename std::remove_pointer&lt; T &gt;::type &gt;::value||std::is_invocable_r&lt; void, typename std::remove_pointer&lt; T &gt;::type, sp_data_reader &gt;::value), int32_t &gt;::type  = -1&gt; </td></tr>
<tr class="memitem:aa20c3a797bfe97ac855bfc495f18c15d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpq__async_1_1database.html#aa20c3a797bfe97ac855bfc495f18c15d">query_reader</a> (const char *sql, const <a class="el" href="classpq__async_1_1parameters.html">parameters</a> &amp;p, const T &amp;acb)</td></tr>
<tr class="memdesc:aa20c3a797bfe97ac855bfc495f18c15d"><td class="mdescLeft">&#160;</td><td class="mdescRight">asynchrounously process a query and returns a <a class="el" href="classpq__async_1_1data__reader.html">pq_async::data_reader</a> as the result  <a href="#aa20c3a797bfe97ac855bfc495f18c15d">More...</a><br /></td></tr>
<tr class="separator:aa20c3a797bfe97ac855bfc495f18c15d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a151fafcba2ea091cbeb120db77358a7e"><td class="memTemplParams" colspan="2">template&lt;typename... PARAMS, typename std::enable_if&lt; std::is_same&lt; sp_data_reader, typename std::remove_pointer&lt; typename select_last&lt; PARAMS... &gt;::type &gt;::type &gt;::value||std::is_array&lt; typename std::remove_pointer&lt; typename select_last&lt; PARAMS... &gt;::type &gt;::type &gt;::value||(!std::is_invocable_r&lt; void, typename std::remove_pointer&lt; typename select_last&lt; PARAMS... &gt;::type &gt;::type, const cb_error &amp;&gt;::value &amp;&amp;!std::is_invocable_r&lt; void, typename std::remove_pointer&lt; typename select_last&lt; PARAMS... &gt;::type &gt;::type, const cb_error &amp;, sp_data_reader &gt;::value &amp;&amp;!std::is_invocable_r&lt; void, typename std::remove_pointer&lt; typename select_last&lt; PARAMS... &gt;::type &gt;::type &gt;::value &amp;&amp;!std::is_invocable_r&lt; void, typename std::remove_pointer&lt; typename select_last&lt; PARAMS... &gt;::type &gt;::type, sp_data_reader &gt;::value), int32_t &gt;::type  = -1&gt; </td></tr>
<tr class="memitem:a151fafcba2ea091cbeb120db77358a7e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacepq__async.html#a44721d94c016db8d76a4360705dbe3a2">sp_data_reader</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpq__async_1_1database.html#a151fafcba2ea091cbeb120db77358a7e">query_reader</a> (const char *sql, const PARAMS &amp;... args)</td></tr>
<tr class="memdesc:a151fafcba2ea091cbeb120db77358a7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">synchrounously process a query and returns a <a class="el" href="classpq__async_1_1data__reader.html">pq_async::data_reader</a> as the result  <a href="#a151fafcba2ea091cbeb120db77358a7e">More...</a><br /></td></tr>
<tr class="separator:a151fafcba2ea091cbeb120db77358a7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cecfc496a504dd4ce828332e742d70a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacepq__async.html#a44721d94c016db8d76a4360705dbe3a2">sp_data_reader</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpq__async_1_1database.html#a5cecfc496a504dd4ce828332e742d70a">query_reader</a> (const char *sql)</td></tr>
<tr class="memdesc:a5cecfc496a504dd4ce828332e742d70a"><td class="mdescLeft">&#160;</td><td class="mdescRight">synchrounously process a query and returns a <a class="el" href="classpq__async_1_1data__reader.html">pq_async::data_reader</a> as the result  <a href="#a5cecfc496a504dd4ce828332e742d70a">More...</a><br /></td></tr>
<tr class="separator:a5cecfc496a504dd4ce828332e742d70a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1e27663e53abadf5a3b1690a5ebf43e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacepq__async.html#a44721d94c016db8d76a4360705dbe3a2">sp_data_reader</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpq__async_1_1database.html#ad1e27663e53abadf5a3b1690a5ebf43e">query_reader</a> (const char *sql, const <a class="el" href="classpq__async_1_1parameters.html">parameters</a> &amp;p)</td></tr>
<tr class="memdesc:ad1e27663e53abadf5a3b1690a5ebf43e"><td class="mdescLeft">&#160;</td><td class="mdescRight">synchrounously process a query and returns a <a class="el" href="classpq__async_1_1data__reader.html">pq_async::data_reader</a> as the result  <a href="#ad1e27663e53abadf5a3b1690a5ebf43e">More...</a><br /></td></tr>
<tr class="separator:ad1e27663e53abadf5a3b1690a5ebf43e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58b13b3e292e1d10fbb3c88d3f8e7c97"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpq__async_1_1database.html#a58b13b3e292e1d10fbb3c88d3f8e7c97">exec_queries</a> (const std::string &amp;sql)</td></tr>
<tr class="memdesc:a58b13b3e292e1d10fbb3c88d3f8e7c97"><td class="mdescLeft">&#160;</td><td class="mdescRight">synchronously parse and execute an sql script  <a href="#a58b13b3e292e1d10fbb3c88d3f8e7c97">More...</a><br /></td></tr>
<tr class="separator:a58b13b3e292e1d10fbb3c88d3f8e7c97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b4c82fb7e0d329e660f0883f3ebde52"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpq__async_1_1database.html#a8b4c82fb7e0d329e660f0883f3ebde52">exec_queries</a> (const std::string &amp;sql, const <a class="el" href="namespacepq__async.html#a03a0284ccd4badf9893eb4463d77a295">async_cb</a> &amp;cb)</td></tr>
<tr class="memdesc:a8b4c82fb7e0d329e660f0883f3ebde52"><td class="mdescLeft">&#160;</td><td class="mdescRight">asynchronously parse and execute an sql script  <a href="#a8b4c82fb7e0d329e660f0883f3ebde52">More...</a><br /></td></tr>
<tr class="separator:a8b4c82fb7e0d329e660f0883f3ebde52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36417ad306bdddfba2eb5540df441992"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacepq__async.html#a88d02184eb14c480a7d0471b3fc54e14">sp_data_large_object</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpq__async_1_1database.html#a36417ad306bdddfba2eb5540df441992">create_lo</a> ()</td></tr>
<tr class="memdesc:a36417ad306bdddfba2eb5540df441992"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a large object.  <a href="#a36417ad306bdddfba2eb5540df441992">More...</a><br /></td></tr>
<tr class="separator:a36417ad306bdddfba2eb5540df441992"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1223a9842f13669c41571d26df2bf55d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacepq__async.html#a88d02184eb14c480a7d0471b3fc54e14">sp_data_large_object</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpq__async_1_1database.html#a1223a9842f13669c41571d26df2bf55d">get_lo</a> (const <a class="el" href="classpq__async_1_1oid.html">pq_async::oid</a> &amp;lo_oid)</td></tr>
<tr class="memdesc:a1223a9842f13669c41571d26df2bf55d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the lo object.  <a href="#a1223a9842f13669c41571d26df2bf55d">More...</a><br /></td></tr>
<tr class="separator:a1223a9842f13669c41571d26df2bf55d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae90ef0a96bf3e71856c5ea298c6061c7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacepq__async.html#a4fabd3b4c1b934d1e2403582cbde422c">sp_data_prepared</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpq__async_1_1database.html#ae90ef0a96bf3e71856c5ea298c6061c7">prepare</a> (const char *name, const char *sql, bool auto_deallocate)</td></tr>
<tr class="memdesc:ae90ef0a96bf3e71856c5ea298c6061c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">synchronously creates a new prepared statement and returns a <a class="el" href="classpq__async_1_1data__prepared.html">data_prepared</a> object  <a href="#ae90ef0a96bf3e71856c5ea298c6061c7">More...</a><br /></td></tr>
<tr class="separator:ae90ef0a96bf3e71856c5ea298c6061c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a902c989297721add4a1c7b37bc5c5063"><td class="memTemplParams" colspan="2">template&lt;typename... PARAMS, typename std::enable_if&lt; std::is_same&lt; sp_data_prepared, typename std::remove_pointer&lt; typename select_last&lt; PARAMS... &gt;::type &gt;::type &gt;::value||std::is_array&lt; typename std::remove_pointer&lt; typename select_last&lt; PARAMS... &gt;::type &gt;::type &gt;::value||(!std::is_invocable_r&lt; void, typename std::remove_pointer&lt; typename select_last&lt; PARAMS... &gt;::type &gt;::type, const cb_error &amp;&gt;::value &amp;&amp;!std::is_invocable_r&lt; void, typename std::remove_pointer&lt; typename select_last&lt; PARAMS... &gt;::type &gt;::type, const cb_error &amp;, sp_data_prepared &gt;::value &amp;&amp;!std::is_invocable_r&lt; void, typename std::remove_pointer&lt; typename select_last&lt; PARAMS... &gt;::type &gt;::type &gt;::value &amp;&amp;!std::is_invocable_r&lt; void, typename std::remove_pointer&lt; typename select_last&lt; PARAMS... &gt;::type &gt;::type, sp_data_prepared &gt;::value), int32_t &gt;::type  = -1&gt; </td></tr>
<tr class="memitem:a902c989297721add4a1c7b37bc5c5063"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacepq__async.html#a4fabd3b4c1b934d1e2403582cbde422c">sp_data_prepared</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpq__async_1_1database.html#a902c989297721add4a1c7b37bc5c5063">prepare</a> (const char *name, const char *sql, bool auto_deallocate, const PARAMS &amp;... args)</td></tr>
<tr class="memdesc:a902c989297721add4a1c7b37bc5c5063"><td class="mdescLeft">&#160;</td><td class="mdescRight">synchronously creates a new prepared statement and returns a <a class="el" href="classpq__async_1_1data__prepared.html">data_prepared</a> object  <a href="#a902c989297721add4a1c7b37bc5c5063">More...</a><br /></td></tr>
<tr class="separator:a902c989297721add4a1c7b37bc5c5063"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fa7bf68b7f220dee0b312ee8763ddb5"><td class="memTemplParams" colspan="2">template&lt;template&lt; typename ... &gt; typename Container, typename ... Args&gt; </td></tr>
<tr class="memitem:a8fa7bf68b7f220dee0b312ee8763ddb5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacepq__async.html#a4fabd3b4c1b934d1e2403582cbde422c">sp_data_prepared</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpq__async_1_1database.html#a8fa7bf68b7f220dee0b312ee8763ddb5">prepare</a> (const char *name, const char *sql, bool auto_deallocate, const Container&lt; <a class="el" href="namespacepq__async.html#a601c482f15f009bd53f3460230c1d9e9">pq_async::data_type</a>, Args... &gt; &amp;types)</td></tr>
<tr class="memdesc:a8fa7bf68b7f220dee0b312ee8763ddb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">synchronously creates a new prepared statement and returns a <a class="el" href="classpq__async_1_1data__prepared.html">data_prepared</a> object  <a href="#a8fa7bf68b7f220dee0b312ee8763ddb5">More...</a><br /></td></tr>
<tr class="separator:a8fa7bf68b7f220dee0b312ee8763ddb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c1a7588d2b8260ecb106ccf329ab873"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpq__async_1_1database.html#a5c1a7588d2b8260ecb106ccf329ab873">prepare</a> (const char *name, const char *sql, bool auto_deallocate, <a class="el" href="namespacepq__async.html#a10ae432e13a6cd45e3151d8203e3df67">value_cb</a>&lt; <a class="el" href="namespacepq__async.html#a4fabd3b4c1b934d1e2403582cbde422c">sp_data_prepared</a> &gt; acb)</td></tr>
<tr class="memdesc:a5c1a7588d2b8260ecb106ccf329ab873"><td class="mdescLeft">&#160;</td><td class="mdescRight">asynchronously creates a new prepared statement  <a href="#a5c1a7588d2b8260ecb106ccf329ab873">More...</a><br /></td></tr>
<tr class="separator:a5c1a7588d2b8260ecb106ccf329ab873"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a600bd693f93240be076ea07779e0a66f"><td class="memTemplParams" colspan="2">template&lt;typename... PARAMS, typename std::enable_if&lt; !std::is_same&lt; sp_data_prepared, typename std::remove_pointer&lt; typename select_last&lt; PARAMS... &gt;::type &gt;::type &gt;::value &amp;&amp;!std::is_array&lt; typename std::remove_pointer&lt; typename select_last&lt; PARAMS... &gt;::type &gt;::type &gt;::value &amp;&amp;(std::is_invocable_r&lt; void, typename std::remove_pointer&lt; typename select_last&lt; PARAMS... &gt;::type &gt;::type, const cb_error &amp;&gt;::value||std::is_invocable_r&lt; void, typename std::remove_pointer&lt; typename select_last&lt; PARAMS... &gt;::type &gt;::type, const cb_error &amp;, sp_data_prepared &gt;::value||std::is_invocable_r&lt; void, typename std::remove_pointer&lt; typename select_last&lt; PARAMS... &gt;::type &gt;::type &gt;::value||std::is_invocable_r&lt; void, typename std::remove_pointer&lt; typename select_last&lt; PARAMS... &gt;::type &gt;::type, sp_data_prepared &gt;::value), int32_t &gt;::type  = -1&gt; </td></tr>
<tr class="memitem:a600bd693f93240be076ea07779e0a66f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpq__async_1_1database.html#a600bd693f93240be076ea07779e0a66f">prepare</a> (const char *name, const char *sql, bool auto_deallocate, const PARAMS &amp;... args)</td></tr>
<tr class="memdesc:a600bd693f93240be076ea07779e0a66f"><td class="mdescLeft">&#160;</td><td class="mdescRight">asynchronously creates a new prepared statement  <a href="#a600bd693f93240be076ea07779e0a66f">More...</a><br /></td></tr>
<tr class="separator:a600bd693f93240be076ea07779e0a66f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b57fd2c782f242f88485e230a196449"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpq__async_1_1database.html#a1b57fd2c782f242f88485e230a196449">prepare</a> (const char *name, const char *sql, bool auto_deallocate, const std::vector&lt; <a class="el" href="namespacepq__async.html#a601c482f15f009bd53f3460230c1d9e9">data_type</a> &gt; &amp;types, <a class="el" href="namespacepq__async.html#a10ae432e13a6cd45e3151d8203e3df67">value_cb</a>&lt; <a class="el" href="namespacepq__async.html#a4fabd3b4c1b934d1e2403582cbde422c">sp_data_prepared</a> &gt; cb)</td></tr>
<tr class="memdesc:a1b57fd2c782f242f88485e230a196449"><td class="mdescLeft">&#160;</td><td class="mdescRight">asynchronously creates a new prepared statement  <a href="#a1b57fd2c782f242f88485e230a196449">More...</a><br /></td></tr>
<tr class="separator:a1b57fd2c782f242f88485e230a196449"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acee7c50fb0a9e8e40c1d1809415700f4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpq__async_1_1database.html#acee7c50fb0a9e8e40c1d1809415700f4">deallocate_prepared</a> (const char *name)</td></tr>
<tr class="memdesc:acee7c50fb0a9e8e40c1d1809415700f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">synchronously delete a prepared statement  <a href="#acee7c50fb0a9e8e40c1d1809415700f4">More...</a><br /></td></tr>
<tr class="separator:acee7c50fb0a9e8e40c1d1809415700f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a697531b94466d86f7043e10f8c1e6a4d"><td class="memTemplParams" colspan="2">template&lt;typename CB , typename std::enable_if&lt; !std::is_array&lt; typename std::remove_pointer&lt; CB &gt;::type &gt;::value &amp;&amp;(std::is_invocable_r&lt; void, typename std::remove_pointer&lt; CB &gt;::type, const cb_error &amp;&gt;::value||std::is_invocable_r&lt; void, typename std::remove_pointer&lt; CB &gt;::type &gt;::value), int32_t &gt;::type  = -1&gt; </td></tr>
<tr class="memitem:a697531b94466d86f7043e10f8c1e6a4d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpq__async_1_1database.html#a697531b94466d86f7043e10f8c1e6a4d">deallocate_prepared</a> (const char *name, const CB &amp;acb)</td></tr>
<tr class="memdesc:a697531b94466d86f7043e10f8c1e6a4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">asynchronously delete a prepared statement  <a href="#a697531b94466d86f7043e10f8c1e6a4d">More...</a><br /></td></tr>
<tr class="separator:a697531b94466d86f7043e10f8c1e6a4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a8ecaef3477c249d250ef37836a12b218"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespacepq__async.html#a832a0bdabf9f28ce1cfe4b5324c0f9b0">sp_database</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpq__async_1_1database.html#a8ecaef3477c249d250ef37836a12b218">open</a> (const std::string &amp;connection_string)</td></tr>
<tr class="memdesc:a8ecaef3477c249d250ef37836a12b218"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates a new database instance using a new strand from the default <a class="el" href="classpq__async_1_1event__queue.html">event_queue</a>  <a href="#a8ecaef3477c249d250ef37836a12b218">More...</a><br /></td></tr>
<tr class="separator:a8ecaef3477c249d250ef37836a12b218"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb8dac3663f64ba3b956b3b5517cd225"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespacepq__async.html#a832a0bdabf9f28ce1cfe4b5324c0f9b0">sp_database</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpq__async_1_1database.html#acb8dac3663f64ba3b956b3b5517cd225">open</a> (<a class="el" href="namespacepq__async.html#aabd5df712722ea308c443767392eb42a">sp_event_strand</a>&lt; int &gt; <a class="el" href="classpq__async_1_1strand.html">strand</a>, const std::string &amp;connection_string)</td></tr>
<tr class="memdesc:acb8dac3663f64ba3b956b3b5517cd225"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates a new database instance usign the specified <a class="el" href="classpq__async_1_1event__strand.html">event_strand</a>  <a href="#acb8dac3663f64ba3b956b3b5517cd225">More...</a><br /></td></tr>
<tr class="separator:acb8dac3663f64ba3b956b3b5517cd225"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4aad3ca4426bb15ee85948bd0a66bc2e"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpq__async_1_1database.html#a4aad3ca4426bb15ee85948bd0a66bc2e">split_queries</a> (const std::string &amp;sql, std::vector&lt; std::string &gt; &amp;queries)</td></tr>
<tr class="separator:a4aad3ca4426bb15ee85948bd0a66bc2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:adb115488bb4890f7fc705ee527ad71e0"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpq__async_1_1database.html#adb115488bb4890f7fc705ee527ad71e0">connection</a></td></tr>
<tr class="separator:adb115488bb4890f7fc705ee527ad71e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afab4905b271f8aabf42aecc3e1f14a93"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpq__async_1_1database.html#afab4905b271f8aabf42aecc3e1f14a93">connection_task</a></td></tr>
<tr class="separator:afab4905b271f8aabf42aecc3e1f14a93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accac599643e0a8c900f765dcf4026344"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpq__async_1_1database.html#accac599643e0a8c900f765dcf4026344">connection_pool</a></td></tr>
<tr class="separator:accac599643e0a8c900f765dcf4026344"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3648c32fa13464804de0657935a79c7"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpq__async_1_1database.html#ad3648c32fa13464804de0657935a79c7">data_large_object</a></td></tr>
<tr class="separator:ad3648c32fa13464804de0657935a79c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9f2c5c4fb0dc288d001d1f9b415b51d"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpq__async_1_1database.html#ac9f2c5c4fb0dc288d001d1f9b415b51d">data_prepared</a></td></tr>
<tr class="separator:ac9f2c5c4fb0dc288d001d1f9b415b51d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="af43de96a0cb32e0ea84ebe7dfa814573"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af43de96a0cb32e0ea84ebe7dfa814573">&#9670;&nbsp;</a></span>~database()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pq_async::database::~database </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="log_8h.html#a50b79ae676f191c1f7761a31e81ffadc">pq_async_log_trace</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a82590553a383f5fad5689091f4d59157"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82590553a383f5fad5689091f4d59157">&#9670;&nbsp;</a></span>begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pq_async::database::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>synchronously starts a new transaction </p>

<p class="reference">References <a class="el" href="classpq__async_1_1connection.html#a8b2cf19486f925b45f0dd0be036f4a91">pq_async::connection::begin_transaction()</a>, and <a class="el" href="classpq__async_1_1database.html#a887fd67d3c7dde55f81ed00e444f2b6f">open_connection()</a>.</p>

</div>
</div>
<a id="a5aadcab4c8393227151e85c07851fd19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5aadcab4c8393227151e85c07851fd19">&#9670;&nbsp;</a></span>begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CB , typename std::enable_if&lt; !std::is_array&lt; typename std::remove_pointer&lt; CB &gt;::type &gt;::value &amp;&amp;(std::is_invocable_r&lt; void, typename std::remove_pointer&lt; CB &gt;::type, const cb_error &amp;&gt;::value||std::is_invocable_r&lt; void, typename std::remove_pointer&lt; CB &gt;::type &gt;::value), int32_t &gt;::type  = -1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pq_async::database::begin </td>
          <td>(</td>
          <td class="paramtype">const CB &amp;&#160;</td>
          <td class="paramname"><em>acb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>asynchronously starts a new transaction </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">CB</td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="data__common_8h.html#a6b856e51a0c469de2ead306082dd9eb6">PQ_ASYNC_VALID_DB_ASY_CALLBACK(CB)</a></td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acb</td><td>async_cb callback to call on completion </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classpq__async_1_1database.html#a6ba12ad8ec40562af85d896cb5ba2f52">in_transaction()</a>, and <a class="el" href="classpq__async_1_1database.html#a887fd67d3c7dde55f81ed00e444f2b6f">open_connection()</a>.</p>

</div>
</div>
<a id="aef547dc40f9f80b743d8aa83ccd54376"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef547dc40f9f80b743d8aa83ccd54376">&#9670;&nbsp;</a></span>close()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pq_async::database::close </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>release the underlying connection this call is always synchronous </p>

<p class="reference">References <a class="el" href="classpq__async_1_1connection__pool.html#a4546a7d8fdc88f53c92052dcd8758adf">pq_async::connection_pool::instance()</a>, and <a class="el" href="classpq__async_1_1connection.html#a87f510590e9149d9dee4a12a2f66e07a">pq_async::connection::release()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classpq__async_1_1data__large__object.html#aeb6df91134fd9f3e8bd3fbfa8b439cb2">pq_async::data_large_object::opened_write()</a>.</p>

</div>
</div>
<a id="a72c1dcc03e68d1baef3268a4e0b683de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72c1dcc03e68d1baef3268a4e0b683de">&#9670;&nbsp;</a></span>commit() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pq_async::database::commit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>synchonously commit current transaction </p>

<p class="reference">References <a class="el" href="classpq__async_1_1connection.html#a67a8127cb23eea2c5c823337ffc4c79e">pq_async::connection::commit_transaction()</a>.</p>

</div>
</div>
<a id="a3faaa9cf9a49e80bd11f21b7257eaa30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3faaa9cf9a49e80bd11f21b7257eaa30">&#9670;&nbsp;</a></span>commit() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CB , typename std::enable_if&lt; !std::is_array&lt; typename std::remove_pointer&lt; CB &gt;::type &gt;::value &amp;&amp;(std::is_invocable_r&lt; void, typename std::remove_pointer&lt; CB &gt;::type, const cb_error &amp;&gt;::value||std::is_invocable_r&lt; void, typename std::remove_pointer&lt; CB &gt;::type &gt;::value), int32_t &gt;::type  = -1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pq_async::database::commit </td>
          <td>(</td>
          <td class="paramtype">const CB &amp;&#160;</td>
          <td class="paramname"><em>acb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>asynchonously commit current transaction </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">CB</td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="data__common_8h.html#a6b856e51a0c469de2ead306082dd9eb6">PQ_ASYNC_VALID_DB_ASY_CALLBACK(CB)</a></td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acb</td><td></td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classpq__async_1_1database.html#a9fd6245f84aa5051a88cba192608b9d2">execute()</a>, <a class="el" href="classpq__async_1_1database.html#a6ba12ad8ec40562af85d896cb5ba2f52">in_transaction()</a>, and <a class="el" href="classpq__async_1_1connection.html#ad554218d7ff7972263600dfd1db6edb8">pq_async::connection::touch()</a>.</p>

</div>
</div>
<a id="a36417ad306bdddfba2eb5540df441992"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36417ad306bdddfba2eb5540df441992">&#9670;&nbsp;</a></span>create_lo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacepq__async.html#a88d02184eb14c480a7d0471b3fc54e14">sp_data_large_object</a> pq_async::database::create_lo </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a large object. </p>
<dl class="section return"><dt>Returns</dt><dd>sp_data_large_object </dd></dl>

<p class="reference">References <a class="el" href="namespacepq__async.html#a601c482f15f009bd53f3460230c1d9e9a130f43112bb8a7a7790ebfc08ee9d6af">pq_async::oid</a>.</p>

<p class="reference">Referenced by <a class="el" href="classpq__async_1_1database.html#ad1e27663e53abadf5a3b1690a5ebf43e">query_reader()</a>.</p>

</div>
</div>
<a id="acee7c50fb0a9e8e40c1d1809415700f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acee7c50fb0a9e8e40c1d1809415700f4">&#9670;&nbsp;</a></span>deallocate_prepared() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pq_async::database::deallocate_prepared </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>synchronously delete a prepared statement </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>the prepared statement name </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classpq__async_1_1database.html#a9fd6245f84aa5051a88cba192608b9d2">execute()</a>, and <a class="el" href="classpq__async_1_1database.html#a887fd67d3c7dde55f81ed00e444f2b6f">open_connection()</a>.</p>

</div>
</div>
<a id="a697531b94466d86f7043e10f8c1e6a4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a697531b94466d86f7043e10f8c1e6a4d">&#9670;&nbsp;</a></span>deallocate_prepared() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CB , typename std::enable_if&lt; !std::is_array&lt; typename std::remove_pointer&lt; CB &gt;::type &gt;::value &amp;&amp;(std::is_invocable_r&lt; void, typename std::remove_pointer&lt; CB &gt;::type, const cb_error &amp;&gt;::value||std::is_invocable_r&lt; void, typename std::remove_pointer&lt; CB &gt;::type &gt;::value), int32_t &gt;::type  = -1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pq_async::database::deallocate_prepared </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CB &amp;&#160;</td>
          <td class="paramname"><em>acb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>asynchronously delete a prepared statement </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">CB</td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="data__common_8h.html#a6b856e51a0c469de2ead306082dd9eb6">PQ_ASYNC_VALID_DB_ASY_CALLBACK(CB)</a></td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>the prepared statement name </td></tr>
    <tr><td class="paramname">acb</td><td>completion void(const cb_error&amp;) callback </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classpq__async_1_1database.html#a887fd67d3c7dde55f81ed00e444f2b6f">open_connection()</a>.</p>

</div>
</div>
<a id="a58b13b3e292e1d10fbb3c88d3f8e7c97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58b13b3e292e1d10fbb3c88d3f8e7c97">&#9670;&nbsp;</a></span>exec_queries() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pq_async::database::exec_queries </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sql</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>synchronously parse and execute an sql script </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sql</td><td>script commands to execute </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="namespacepq__async.html#ad0376faea10ade81e623b4b537efa0bf">pq_async::join()</a>, and <a class="el" href="log_8h.html#aad2df066a431c64d546422474a083bfd">pq_async_log_debug</a>.</p>

<p class="reference">Referenced by <a class="el" href="classpq__async_1_1database.html#ad1e27663e53abadf5a3b1690a5ebf43e">query_reader()</a>.</p>

</div>
</div>
<a id="a8b4c82fb7e0d329e660f0883f3ebde52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b4c82fb7e0d329e660f0883f3ebde52">&#9670;&nbsp;</a></span>exec_queries() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pq_async::database::exec_queries </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sql</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacepq__async.html#a03a0284ccd4badf9893eb4463d77a295">async_cb</a> &amp;&#160;</td>
          <td class="paramname"><em>cb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>asynchronously parse and execute an sql script </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sql</td><td>script commands to execute </td></tr>
    <tr><td class="paramname">cb</td><td>callback to call on completion or error cb: void(const cb_error&amp; err) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9fd6245f84aa5051a88cba192608b9d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fd6245f84aa5051a88cba192608b9d2">&#9670;&nbsp;</a></span>execute() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... PARAMS, typename std::enable_if&lt; !std::is_same&lt; int, typename std::remove_pointer&lt; typename select_last&lt; PARAMS... &gt;::type &gt;::type &gt;::value &amp;&amp;!std::is_array&lt; typename std::remove_pointer&lt; typename select_last&lt; PARAMS... &gt;::type &gt;::type &gt;::value &amp;&amp;(std::is_invocable_r&lt; void, typename std::remove_pointer&lt; typename select_last&lt; PARAMS... &gt;::type &gt;::type, const cb_error &amp;&gt;::value||std::is_invocable_r&lt; void, typename std::remove_pointer&lt; typename select_last&lt; PARAMS... &gt;::type &gt;::type, const cb_error &amp;, int &gt;::value||std::is_invocable_r&lt; void, typename std::remove_pointer&lt; typename select_last&lt; PARAMS... &gt;::type &gt;::type &gt;::value||std::is_invocable_r&lt; void, typename std::remove_pointer&lt; typename select_last&lt; PARAMS... &gt;::type &gt;::type, int &gt;::value), int32_t &gt;::type  = -1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pq_async::database::execute </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>sql</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PARAMS &amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>asynchrounously process a query and returns the number of rows affected by insert, update and delete </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">PARAMS</td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="data__common_8h.html#ac1db2b7cac33dd3352f33ea8b100ec26">PQ_ASYNC_VALID_DB_CALLBACK(int)</a></td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sql</td><td>the SQL query to process </td></tr>
    <tr><td class="paramname">args</td><td>query parameters, the last parameter is the query callback <a class="el" href="namespacepq__async.html#a10ae432e13a6cd45e3151d8203e3df67">pq_async::value_cb&lt;int&gt;</a> </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="database_8h.html#ae7d37c8d7f7d03ad0b6d47469d8b7fb5">_PQ_ASYNC_SEND_QRY_BODY_PARAMS</a>.</p>

<p class="reference">Referenced by <a class="el" href="classpq__async_1_1database.html#a3faaa9cf9a49e80bd11f21b7257eaa30">commit()</a>, <a class="el" href="classpq__async_1_1database.html#acee7c50fb0a9e8e40c1d1809415700f4">deallocate_prepared()</a>, <a class="el" href="classpq__async_1_1database.html#a9c602c9c427368e0d11fdc585bab9da5">release_savepoint()</a>, <a class="el" href="classpq__async_1_1database.html#ab347754cd442aa93a1cd6201036c49c5">rollback_savepoint()</a>, <a class="el" href="classpq__async_1_1database.html#a5ac85db4dec7a56ad44309bc18f02670">roollback()</a>, and <a class="el" href="classpq__async_1_1database.html#acb121211b73fffdb837881a04361c830">set_savepoint()</a>.</p>

</div>
</div>
<a id="a9635cb56a1dec676fc6e858523977bfa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9635cb56a1dec676fc6e858523977bfa">&#9670;&nbsp;</a></span>execute() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename std::enable_if&lt; !std::is_array&lt; typename std::remove_pointer&lt; T &gt;::type &gt;::value &amp;&amp;(std::is_invocable_r&lt; void, typename std::remove_pointer&lt; T &gt;::type, const cb_error &amp;&gt;::value||std::is_invocable_r&lt; void, typename std::remove_pointer&lt; T &gt;::type, const cb_error &amp;, int &gt;::value||std::is_invocable_r&lt; void, typename std::remove_pointer&lt; T &gt;::type &gt;::value||std::is_invocable_r&lt; void, typename std::remove_pointer&lt; T &gt;::type, int &gt;::value), int32_t &gt;::type  = -1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pq_async::database::execute </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>sql</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpq__async_1_1parameters.html">parameters</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>acb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>asynchrounously process a query and returns the number of rows affected by insert, update and delete </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="data__common_8h.html#a4ee3eac68c7f1f882e04611fc54cce06">PQ_ASYNC_VALID_DB_VAL_CALLBACK(T</a>,int)</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sql</td><td>the SQL query to process </td></tr>
    <tr><td class="paramname">p</td><td>query parameters </td></tr>
    <tr><td class="paramname">acb</td><td>completion void(const cb_error&amp;, int) callback </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="database_8h.html#af440556d7928b1cd6d84eefacbd73ae4">_PQ_ASYNC_SEND_QRY_BODY_T</a>, and <a class="el" href="data__common_8h.html#ae45378768871c363d5d9d3c8e8a61155">PQ_ASYNC_INVALID_DB_CALLBACK</a>.</p>

</div>
</div>
<a id="ae28a4bcb1a9178e91880254ae161b8d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae28a4bcb1a9178e91880254ae161b8d6">&#9670;&nbsp;</a></span>execute() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... PARAMS, typename std::enable_if&lt; std::is_same&lt; int, typename std::remove_pointer&lt; typename select_last&lt; PARAMS... &gt;::type &gt;::type &gt;::value||std::is_array&lt; typename std::remove_pointer&lt; typename select_last&lt; PARAMS... &gt;::type &gt;::type &gt;::value||(!std::is_invocable_r&lt; void, typename std::remove_pointer&lt; typename select_last&lt; PARAMS... &gt;::type &gt;::type, const cb_error &amp;&gt;::value &amp;&amp;!std::is_invocable_r&lt; void, typename std::remove_pointer&lt; typename select_last&lt; PARAMS... &gt;::type &gt;::type, const cb_error &amp;, int &gt;::value &amp;&amp;!std::is_invocable_r&lt; void, typename std::remove_pointer&lt; typename select_last&lt; PARAMS... &gt;::type &gt;::type &gt;::value &amp;&amp;!std::is_invocable_r&lt; void, typename std::remove_pointer&lt; typename select_last&lt; PARAMS... &gt;::type &gt;::type, int &gt;::value), int32_t &gt;::type  = -1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int32_t pq_async::database::execute </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>sql</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PARAMS &amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>synchrounously process a query and returns the number of rows affected by insert, update and delete </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">PARAMS</td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="data__common_8h.html#ae45378768871c363d5d9d3c8e8a61155">PQ_ASYNC_INVALID_DB_CALLBACK(int)</a></td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sql</td><td>the SQL query to process </td></tr>
    <tr><td class="paramname">args</td><td>query parameters </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int32_t the number of record processed </dd></dl>

<p class="reference">References <a class="el" href="database_8h.html#a8e456322de870321e78f8703b2581bb1">_PQ_ASYNC_SEND_QRY_BODY_SYNC</a>.</p>

</div>
</div>
<a id="a613cd93dcb688e1f199083c07ec8ea5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a613cd93dcb688e1f199083c07ec8ea5e">&#9670;&nbsp;</a></span>execute() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int32_t pq_async::database::execute </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>sql</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>synchrounously process a query and returns the number of rows affected by insert, update and delete </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sql</td><td>the SQL query to process </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int32_t the number of record processed </dd></dl>

<p class="reference">References <a class="el" href="database_8h.html#a8e456322de870321e78f8703b2581bb1">_PQ_ASYNC_SEND_QRY_BODY_SYNC</a>.</p>

</div>
</div>
<a id="acf61f88a03a8b8d97361d13aab594af3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf61f88a03a8b8d97361d13aab594af3">&#9670;&nbsp;</a></span>execute() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int32_t pq_async::database::execute </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>sql</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpq__async_1_1parameters.html">parameters</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>synchrounously process a query and returns the number of rows affected by insert, update and delete </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sql</td><td>the SQL query to process </td></tr>
    <tr><td class="paramname">p</td><td>query parameters </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int32_t the number of record processed </dd></dl>

<p class="reference">References <a class="el" href="database_8h.html#a8e456322de870321e78f8703b2581bb1">_PQ_ASYNC_SEND_QRY_BODY_SYNC</a>, and <a class="el" href="data__common_8h.html#ac1db2b7cac33dd3352f33ea8b100ec26">PQ_ASYNC_VALID_DB_CALLBACK</a>.</p>

</div>
</div>
<a id="a1223a9842f13669c41571d26df2bf55d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1223a9842f13669c41571d26df2bf55d">&#9670;&nbsp;</a></span>get_lo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacepq__async.html#a88d02184eb14c480a7d0471b3fc54e14">sp_data_large_object</a> pq_async::database::get_lo </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpq__async_1_1oid.html">pq_async::oid</a> &amp;&#160;</td>
          <td class="paramname"><em>lo_oid</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the lo object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lo_oid</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>sp_data_large_object </dd></dl>

<p class="reference">Referenced by <a class="el" href="classpq__async_1_1database.html#ad1e27663e53abadf5a3b1690a5ebf43e">query_reader()</a>.</p>

</div>
</div>
<a id="ad80a834e90da98e0dc9c7d9cbd200615"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad80a834e90da98e0dc9c7d9cbd200615">&#9670;&nbsp;</a></span>get_strand()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacepq__async.html#aabd5df712722ea308c443767392eb42a">sp_event_strand</a>&lt;int&gt; pq_async::database::get_strand </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">Referenced by <a class="el" href="classpq__async_1_1connection.html#ad7f2937349150dfccb7066815a9111ac">pq_async::connection::strand()</a>.</p>

</div>
</div>
<a id="a6ba12ad8ec40562af85d896cb5ba2f52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ba12ad8ec40562af85d896cb5ba2f52">&#9670;&nbsp;</a></span>in_transaction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pq_async::database::in_transaction </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns if a transaction is in progress </p>
<dl class="section return"><dt>Returns</dt><dd>true if a transaction is in progress </dd>
<dd>
false if no transaction is in progress </dd></dl>

<p class="reference">References <a class="el" href="classpq__async_1_1connection.html#a5a8bcb24ec24ef8ebb9fa2916d56fcbb">pq_async::connection::in_transaction()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classpq__async_1_1database.html#a5aadcab4c8393227151e85c07851fd19">begin()</a>, <a class="el" href="classpq__async_1_1database.html#a3faaa9cf9a49e80bd11f21b7257eaa30">commit()</a>, <a class="el" href="classpq__async_1_1database.html#a9c602c9c427368e0d11fdc585bab9da5">release_savepoint()</a>, <a class="el" href="classpq__async_1_1database.html#ab347754cd442aa93a1cd6201036c49c5">rollback_savepoint()</a>, <a class="el" href="classpq__async_1_1database.html#a5ac85db4dec7a56ad44309bc18f02670">roollback()</a>, and <a class="el" href="classpq__async_1_1database.html#acb121211b73fffdb837881a04361c830">set_savepoint()</a>.</p>

</div>
</div>
<a id="a8ecaef3477c249d250ef37836a12b218"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ecaef3477c249d250ef37836a12b218">&#9670;&nbsp;</a></span>open() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="namespacepq__async.html#a832a0bdabf9f28ce1cfe4b5324c0f9b0">sp_database</a> pq_async::database::open </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>connection_string</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>creates a new database instance using a new strand from the default <a class="el" href="classpq__async_1_1event__queue.html">event_queue</a> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">connection_string</td><td>the connection string used for that instance </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>sp_database </dd></dl>

<p class="reference">References <a class="el" href="classpq__async_1_1event__queue.html#aba950a379dae68792bde1858698372f2">pq_async::event_queue::get_default()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classpq__async_1_1data__large__object.html#aeb6df91134fd9f3e8bd3fbfa8b439cb2">pq_async::data_large_object::opened_write()</a>, <a class="el" href="classpq__async_1_1tests_1_1db__test__base.html#aca90aa9b457027a0b490a8a5b6f3e172">pq_async::tests::db_test_base::SetUp()</a>, and <a class="el" href="namespacepq__async_1_1tests.html#ab51d9ce50322961d4d910a00c91734f8">pq_async::tests::TEST_F()</a>.</p>

</div>
</div>
<a id="acb8dac3663f64ba3b956b3b5517cd225"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb8dac3663f64ba3b956b3b5517cd225">&#9670;&nbsp;</a></span>open() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="namespacepq__async.html#a832a0bdabf9f28ce1cfe4b5324c0f9b0">sp_database</a> pq_async::database::open </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepq__async.html#aabd5df712722ea308c443767392eb42a">sp_event_strand</a>&lt; int &gt;&#160;</td>
          <td class="paramname"><em>strand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>connection_string</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>creates a new database instance usign the specified <a class="el" href="classpq__async_1_1event__strand.html">event_strand</a> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">strand</td><td>the <a class="el" href="classpq__async_1_1event__strand.html">pq_async::event_strand</a> to use </td></tr>
    <tr><td class="paramname">connection_string</td><td>the connection string used for that instance </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>sp_database </dd></dl>

<p class="reference">References <a class="el" href="classpq__async_1_1connection.html#ae00c9291594ec0e69154ba4e0a160413">pq_async::connection::conn()</a>, <a class="el" href="log_8h.html#a50b79ae676f191c1f7761a31e81ffadc">pq_async_log_trace</a>, <a class="el" href="classpq__async_1_1database.html#a4aad3ca4426bb15ee85948bd0a66bc2e">split_queries()</a>, and <a class="el" href="classpq__async_1_1database.html#a35e2b15a91190f410df94162f6f0c13b">working()</a>.</p>

</div>
</div>
<a id="a887fd67d3c7dde55f81ed00e444f2b6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a887fd67d3c7dde55f81ed00e444f2b6f">&#9670;&nbsp;</a></span>open_connection() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacepq__async.html#abb00b15e5ba4cb34858e8de109777cbe">sp_connection_lock</a> pq_async::database::open_connection </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>timeout_ms</em> = <code>5000</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>synchronously try to acquire and open a connection </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeout_ms</td><td>milliseconds to wait before failure, default to 5000 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>sp_connection_lock </dd></dl>

<p class="reference">References <a class="el" href="classpq__async_1_1connection__pool.html#a0a226991cb5c873e19a8f5830509cb5b">pq_async::connection_pool::get_connection()</a>, <a class="el" href="classpq__async_1_1connection__pool.html#a4546a7d8fdc88f53c92052dcd8758adf">pq_async::connection_pool::instance()</a>, <a class="el" href="classpq__async_1_1connection.html#ae667149b58c0fecb1b768e35877f5cdb">pq_async::connection::open_connection()</a>, <a class="el" href="data__common_8h.html#a4ee3eac68c7f1f882e04611fc54cce06">PQ_ASYNC_VALID_DB_VAL_CALLBACK</a>, and <a class="el" href="classpq__async_1_1connection.html#a97b022948211d7c4c2f925e57f4669a8">pq_async::connection::reserve()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classpq__async_1_1database.html#a82590553a383f5fad5689091f4d59157">begin()</a>, <a class="el" href="classpq__async_1_1database.html#acee7c50fb0a9e8e40c1d1809415700f4">deallocate_prepared()</a>, <a class="el" href="classpq__async_1_1database.html#a8fa7bf68b7f220dee0b312ee8763ddb5">prepare()</a>, and <a class="el" href="classpq__async_1_1database.html#a7daa2da6f901e99311da698a29f9ce71">query_reader()</a>.</p>

</div>
</div>
<a id="a8add67ba6b082ed046013dcb52e2358d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8add67ba6b082ed046013dcb52e2358d">&#9670;&nbsp;</a></span>open_connection() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CB , typename std::enable_if&lt; !std::is_array&lt; typename std::remove_pointer&lt; CB &gt;::type &gt;::value &amp;&amp;(std::is_invocable_r&lt; void, typename std::remove_pointer&lt; CB &gt;::type, const cb_error &amp;&gt;::value||std::is_invocable_r&lt; void, typename std::remove_pointer&lt; CB &gt;::type, const cb_error &amp;, sp_connection_lock &gt;::value||std::is_invocable_r&lt; void, typename std::remove_pointer&lt; CB &gt;::type &gt;::value||std::is_invocable_r&lt; void, typename std::remove_pointer&lt; CB &gt;::type, sp_connection_lock &gt;::value), int32_t &gt;::type  = -1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pq_async::database::open_connection </td>
          <td>(</td>
          <td class="paramtype">const CB &amp;&#160;</td>
          <td class="paramname"><em>acb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>timeout_ms</em> = <code>5000</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>asynchronously try to acquire and open a connection </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">CB</td><td></td></tr>
    <tr><td class="paramname">PQ_ASYNC_VALID_DB_CALLBACK_T(CB,bool)</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acb</td><td></td></tr>
    <tr><td class="paramname">timeout_ms</td><td>milliseconds to wait before failure, default to 5000 </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="log_8h.html#aad2df066a431c64d546422474a083bfd">pq_async_log_debug</a>.</p>

</div>
</div>
<a id="ae90ef0a96bf3e71856c5ea298c6061c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae90ef0a96bf3e71856c5ea298c6061c7">&#9670;&nbsp;</a></span>prepare() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacepq__async.html#a4fabd3b4c1b934d1e2403582cbde422c">sp_data_prepared</a> pq_async::database::prepare </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>sql</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>auto_deallocate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>synchronously creates a new prepared statement and returns a <a class="el" href="classpq__async_1_1data__prepared.html">data_prepared</a> object </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>the prepared statement name </td></tr>
    <tr><td class="paramname">sql</td><td>the prepared statement query </td></tr>
    <tr><td class="paramname">auto_deallocate</td><td>if the prepared statement shoul be delete on </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>sp_data_prepared </dd></dl>

<p class="reference">References <a class="el" href="data__common_8h.html#ae45378768871c363d5d9d3c8e8a61155">PQ_ASYNC_INVALID_DB_CALLBACK</a>.</p>

<p class="reference">Referenced by <a class="el" href="classpq__async_1_1database.html#a902c989297721add4a1c7b37bc5c5063">prepare()</a>.</p>

</div>
</div>
<a id="a902c989297721add4a1c7b37bc5c5063"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a902c989297721add4a1c7b37bc5c5063">&#9670;&nbsp;</a></span>prepare() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... PARAMS, typename std::enable_if&lt; std::is_same&lt; sp_data_prepared, typename std::remove_pointer&lt; typename select_last&lt; PARAMS... &gt;::type &gt;::type &gt;::value||std::is_array&lt; typename std::remove_pointer&lt; typename select_last&lt; PARAMS... &gt;::type &gt;::type &gt;::value||(!std::is_invocable_r&lt; void, typename std::remove_pointer&lt; typename select_last&lt; PARAMS... &gt;::type &gt;::type, const cb_error &amp;&gt;::value &amp;&amp;!std::is_invocable_r&lt; void, typename std::remove_pointer&lt; typename select_last&lt; PARAMS... &gt;::type &gt;::type, const cb_error &amp;, sp_data_prepared &gt;::value &amp;&amp;!std::is_invocable_r&lt; void, typename std::remove_pointer&lt; typename select_last&lt; PARAMS... &gt;::type &gt;::type &gt;::value &amp;&amp;!std::is_invocable_r&lt; void, typename std::remove_pointer&lt; typename select_last&lt; PARAMS... &gt;::type &gt;::type, sp_data_prepared &gt;::value), int32_t &gt;::type  = -1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacepq__async.html#a4fabd3b4c1b934d1e2403582cbde422c">sp_data_prepared</a> pq_async::database::prepare </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>sql</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>auto_deallocate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PARAMS &amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>synchronously creates a new prepared statement and returns a <a class="el" href="classpq__async_1_1data__prepared.html">data_prepared</a> object </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">PARAMS</td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="data__common_8h.html#ae45378768871c363d5d9d3c8e8a61155">PQ_ASYNC_INVALID_DB_CALLBACK(sp_data_prepared)</a></td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>the prepared statement name </td></tr>
    <tr><td class="paramname">sql</td><td>the prepared statement query </td></tr>
    <tr><td class="paramname">auto_deallocate</td><td>if the prepared statement shoul be delete on </td></tr>
    <tr><td class="paramname">args</td><td>list of query parameter's data_type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>sp_data_prepared </dd></dl>

<p class="reference">References <a class="el" href="classpq__async_1_1database.html#ae90ef0a96bf3e71856c5ea298c6061c7">prepare()</a>.</p>

</div>
</div>
<a id="a8fa7bf68b7f220dee0b312ee8763ddb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fa7bf68b7f220dee0b312ee8763ddb5">&#9670;&nbsp;</a></span>prepare() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename ... &gt; typename Container, typename ... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacepq__async.html#a4fabd3b4c1b934d1e2403582cbde422c">sp_data_prepared</a> pq_async::database::prepare </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>sql</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>auto_deallocate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Container&lt; <a class="el" href="namespacepq__async.html#a601c482f15f009bd53f3460230c1d9e9">pq_async::data_type</a>, Args... &gt; &amp;&#160;</td>
          <td class="paramname"><em>types</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>synchronously creates a new prepared statement and returns a <a class="el" href="classpq__async_1_1data__prepared.html">data_prepared</a> object </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Container</td><td></td></tr>
    <tr><td class="paramname">Args</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>the prepared statement name </td></tr>
    <tr><td class="paramname">sql</td><td>the prepared statement query </td></tr>
    <tr><td class="paramname">auto_deallocate</td><td>if the prepared statement shoul be delete on <a class="el" href="classpq__async_1_1data__prepared.html">data_prepared</a> object destruction </td></tr>
    <tr><td class="paramname">types</td><td>list of query parameter's data_type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>sp_data_prepared </dd></dl>

<p class="reference">References <a class="el" href="classpq__async_1_1database.html#a887fd67d3c7dde55f81ed00e444f2b6f">open_connection()</a>.</p>

</div>
</div>
<a id="a5c1a7588d2b8260ecb106ccf329ab873"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c1a7588d2b8260ecb106ccf329ab873">&#9670;&nbsp;</a></span>prepare() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pq_async::database::prepare </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>sql</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>auto_deallocate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepq__async.html#a10ae432e13a6cd45e3151d8203e3df67">value_cb</a>&lt; <a class="el" href="namespacepq__async.html#a4fabd3b4c1b934d1e2403582cbde422c">sp_data_prepared</a> &gt;&#160;</td>
          <td class="paramname"><em>acb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>asynchronously creates a new prepared statement </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>the prepared statement name </td></tr>
    <tr><td class="paramname">sql</td><td>the prepared statement query </td></tr>
    <tr><td class="paramname">auto_deallocate</td><td>if the prepared statement shoul be delete on </td></tr>
    <tr><td class="paramname">acb</td><td>completion void(const cb_error&amp;, sp_data_prepared) callback </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="data__common_8h.html#ac1db2b7cac33dd3352f33ea8b100ec26">PQ_ASYNC_VALID_DB_CALLBACK</a>, and <a class="el" href="classpq__async_1_1database.html#ae90ef0a96bf3e71856c5ea298c6061c7">prepare()</a>.</p>

</div>
</div>
<a id="a600bd693f93240be076ea07779e0a66f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a600bd693f93240be076ea07779e0a66f">&#9670;&nbsp;</a></span>prepare() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... PARAMS, typename std::enable_if&lt; !std::is_same&lt; sp_data_prepared, typename std::remove_pointer&lt; typename select_last&lt; PARAMS... &gt;::type &gt;::type &gt;::value &amp;&amp;!std::is_array&lt; typename std::remove_pointer&lt; typename select_last&lt; PARAMS... &gt;::type &gt;::type &gt;::value &amp;&amp;(std::is_invocable_r&lt; void, typename std::remove_pointer&lt; typename select_last&lt; PARAMS... &gt;::type &gt;::type, const cb_error &amp;&gt;::value||std::is_invocable_r&lt; void, typename std::remove_pointer&lt; typename select_last&lt; PARAMS... &gt;::type &gt;::type, const cb_error &amp;, sp_data_prepared &gt;::value||std::is_invocable_r&lt; void, typename std::remove_pointer&lt; typename select_last&lt; PARAMS... &gt;::type &gt;::type &gt;::value||std::is_invocable_r&lt; void, typename std::remove_pointer&lt; typename select_last&lt; PARAMS... &gt;::type &gt;::type, sp_data_prepared &gt;::value), int32_t &gt;::type  = -1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pq_async::database::prepare </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>sql</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>auto_deallocate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PARAMS &amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>asynchronously creates a new prepared statement </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">PARAMS</td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="data__common_8h.html#ac1db2b7cac33dd3352f33ea8b100ec26">PQ_ASYNC_VALID_DB_CALLBACK(sp_data_prepared)</a></td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>the prepared statement name </td></tr>
    <tr><td class="paramname">sql</td><td>the prepared statement query </td></tr>
    <tr><td class="paramname">auto_deallocate</td><td>if the prepared statement shoul be delete on </td></tr>
    <tr><td class="paramname">args</td><td>list of query parameter's data_type, the last argument is the completion void(const cb_error&amp;, sp_data_prepared) callback </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="namespacepq__async.html#abb8c48ea4f371f0fcf113c99e584f5c0">pq_async::get_last()</a>, and <a class="el" href="classpq__async_1_1database.html#ae90ef0a96bf3e71856c5ea298c6061c7">prepare()</a>.</p>

</div>
</div>
<a id="a1b57fd2c782f242f88485e230a196449"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b57fd2c782f242f88485e230a196449">&#9670;&nbsp;</a></span>prepare() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pq_async::database::prepare </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>sql</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>auto_deallocate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacepq__async.html#a601c482f15f009bd53f3460230c1d9e9">data_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>types</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepq__async.html#a10ae432e13a6cd45e3151d8203e3df67">value_cb</a>&lt; <a class="el" href="namespacepq__async.html#a4fabd3b4c1b934d1e2403582cbde422c">sp_data_prepared</a> &gt;&#160;</td>
          <td class="paramname"><em>cb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>asynchronously creates a new prepared statement </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>the prepared statement name </td></tr>
    <tr><td class="paramname">sql</td><td>the prepared statement query </td></tr>
    <tr><td class="paramname">auto_deallocate</td><td>if the prepared statement shoul be delete on </td></tr>
    <tr><td class="paramname">types</td><td>list of query parameter's data_type </td></tr>
    <tr><td class="paramname">cb</td><td>completion void(const cb_error&amp;, sp_data_prepared) callback </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classpq__async_1_1database.html#a887fd67d3c7dde55f81ed00e444f2b6f">open_connection()</a>.</p>

</div>
</div>
<a id="a074d2edf72459f64fa9ab85ec58c4714"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a074d2edf72459f64fa9ab85ec58c4714">&#9670;&nbsp;</a></span>query() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... PARAMS, typename std::enable_if&lt; !std::is_same&lt; sp_data_table, typename std::remove_pointer&lt; typename select_last&lt; PARAMS... &gt;::type &gt;::type &gt;::value &amp;&amp;!std::is_array&lt; typename std::remove_pointer&lt; typename select_last&lt; PARAMS... &gt;::type &gt;::type &gt;::value &amp;&amp;(std::is_invocable_r&lt; void, typename std::remove_pointer&lt; typename select_last&lt; PARAMS... &gt;::type &gt;::type, const cb_error &amp;&gt;::value||std::is_invocable_r&lt; void, typename std::remove_pointer&lt; typename select_last&lt; PARAMS... &gt;::type &gt;::type, const cb_error &amp;, sp_data_table &gt;::value||std::is_invocable_r&lt; void, typename std::remove_pointer&lt; typename select_last&lt; PARAMS... &gt;::type &gt;::type &gt;::value||std::is_invocable_r&lt; void, typename std::remove_pointer&lt; typename select_last&lt; PARAMS... &gt;::type &gt;::type, sp_data_table &gt;::value), int32_t &gt;::type  = -1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pq_async::database::query </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>sql</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PARAMS &amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>asynchrounously process a query and returns a <a class="el" href="classpq__async_1_1data__table.html">pq_async::data_table</a> as the result </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">PARAMS</td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="data__common_8h.html#ac1db2b7cac33dd3352f33ea8b100ec26">PQ_ASYNC_VALID_DB_CALLBACK(sp_data_table)</a></td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sql</td><td>the SQL query to process </td></tr>
    <tr><td class="paramname">args</td><td>query parameters, the last parameter is the completion void(const cb_error&amp;, sp_data_table) callback </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="database_8h.html#ae7d37c8d7f7d03ad0b6d47469d8b7fb5">_PQ_ASYNC_SEND_QRY_BODY_PARAMS</a>.</p>

</div>
</div>
<a id="a7432fbc488a3f489f0a462f4fd3f8acc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7432fbc488a3f489f0a462f4fd3f8acc">&#9670;&nbsp;</a></span>query() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename std::enable_if&lt; !std::is_array&lt; typename std::remove_pointer&lt; T &gt;::type &gt;::value &amp;&amp;(std::is_invocable_r&lt; void, typename std::remove_pointer&lt; T &gt;::type, const cb_error &amp;&gt;::value||std::is_invocable_r&lt; void, typename std::remove_pointer&lt; T &gt;::type, const cb_error &amp;, sp_data_table &gt;::value||std::is_invocable_r&lt; void, typename std::remove_pointer&lt; T &gt;::type &gt;::value||std::is_invocable_r&lt; void, typename std::remove_pointer&lt; T &gt;::type, sp_data_table &gt;::value), int32_t &gt;::type  = -1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pq_async::database::query </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>sql</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpq__async_1_1parameters.html">parameters</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>acb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>asynchrounously process a query and returns a <a class="el" href="classpq__async_1_1data__table.html">pq_async::data_table</a> as the result </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="data__common_8h.html#a4ee3eac68c7f1f882e04611fc54cce06">PQ_ASYNC_VALID_DB_VAL_CALLBACK(T</a>,sp_data_table)</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sql</td><td>the SQL query to process </td></tr>
    <tr><td class="paramname">p</td><td>query parameters </td></tr>
    <tr><td class="paramname">acb</td><td>completion void(const cb_error&amp;, sp_data_table) callback </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="database_8h.html#af440556d7928b1cd6d84eefacbd73ae4">_PQ_ASYNC_SEND_QRY_BODY_T</a>, and <a class="el" href="data__common_8h.html#ae45378768871c363d5d9d3c8e8a61155">PQ_ASYNC_INVALID_DB_CALLBACK</a>.</p>

</div>
</div>
<a id="a76c49b45b48515b4f2d16add7f478584"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76c49b45b48515b4f2d16add7f478584">&#9670;&nbsp;</a></span>query() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... PARAMS, typename std::enable_if&lt; std::is_same&lt; sp_data_table, typename std::remove_pointer&lt; typename select_last&lt; PARAMS... &gt;::type &gt;::type &gt;::value||std::is_array&lt; typename std::remove_pointer&lt; typename select_last&lt; PARAMS... &gt;::type &gt;::type &gt;::value||(!std::is_invocable_r&lt; void, typename std::remove_pointer&lt; typename select_last&lt; PARAMS... &gt;::type &gt;::type, const cb_error &amp;&gt;::value &amp;&amp;!std::is_invocable_r&lt; void, typename std::remove_pointer&lt; typename select_last&lt; PARAMS... &gt;::type &gt;::type, const cb_error &amp;, sp_data_table &gt;::value &amp;&amp;!std::is_invocable_r&lt; void, typename std::remove_pointer&lt; typename select_last&lt; PARAMS... &gt;::type &gt;::type &gt;::value &amp;&amp;!std::is_invocable_r&lt; void, typename std::remove_pointer&lt; typename select_last&lt; PARAMS... &gt;::type &gt;::type, sp_data_table &gt;::value), int32_t &gt;::type  = -1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacepq__async.html#ac55315e08f6f76bc2dfb7f0cf3b27073">sp_data_table</a> pq_async::database::query </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>sql</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PARAMS &amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>synchrounously process a query and returns a <a class="el" href="classpq__async_1_1data__table.html">pq_async::data_table</a> as the result </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">PARAMS</td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="data__common_8h.html#ae45378768871c363d5d9d3c8e8a61155">PQ_ASYNC_INVALID_DB_CALLBACK(sp_data_table)</a></td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sql</td><td>the SQL query to process </td></tr>
    <tr><td class="paramname">args</td><td>query parameters </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>sp_data_table </dd></dl>

<p class="reference">References <a class="el" href="database_8h.html#a8e456322de870321e78f8703b2581bb1">_PQ_ASYNC_SEND_QRY_BODY_SYNC</a>.</p>

</div>
</div>
<a id="ac1835e3bbfd66af6041f93cb740b24da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1835e3bbfd66af6041f93cb740b24da">&#9670;&nbsp;</a></span>query() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacepq__async.html#ac55315e08f6f76bc2dfb7f0cf3b27073">sp_data_table</a> pq_async::database::query </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>sql</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>synchrounously process a query and returns a <a class="el" href="classpq__async_1_1data__table.html">pq_async::data_table</a> as the result </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sql</td><td>the SQL query to process </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>sp_data_table </dd></dl>

<p class="reference">References <a class="el" href="database_8h.html#a8e456322de870321e78f8703b2581bb1">_PQ_ASYNC_SEND_QRY_BODY_SYNC</a>.</p>

</div>
</div>
<a id="a03d9639786149f61cacc7de62af28f4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03d9639786149f61cacc7de62af28f4c">&#9670;&nbsp;</a></span>query() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacepq__async.html#ac55315e08f6f76bc2dfb7f0cf3b27073">sp_data_table</a> pq_async::database::query </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>sql</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpq__async_1_1parameters.html">parameters</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>synchrounously process a query and returns a <a class="el" href="classpq__async_1_1data__table.html">pq_async::data_table</a> as the result </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sql</td><td>the SQL query to process </td></tr>
    <tr><td class="paramname">p</td><td>query parameters </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>sp_data_table </dd></dl>

<p class="reference">References <a class="el" href="database_8h.html#a8e456322de870321e78f8703b2581bb1">_PQ_ASYNC_SEND_QRY_BODY_SYNC</a>, and <a class="el" href="data__common_8h.html#ac1db2b7cac33dd3352f33ea8b100ec26">PQ_ASYNC_VALID_DB_CALLBACK</a>.</p>

</div>
</div>
<a id="a7daa2da6f901e99311da698a29f9ce71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7daa2da6f901e99311da698a29f9ce71">&#9670;&nbsp;</a></span>query_reader() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... PARAMS, typename std::enable_if&lt; !std::is_same&lt; sp_data_reader, typename std::remove_pointer&lt; typename select_last&lt; PARAMS... &gt;::type &gt;::type &gt;::value &amp;&amp;!std::is_array&lt; typename std::remove_pointer&lt; typename select_last&lt; PARAMS... &gt;::type &gt;::type &gt;::value &amp;&amp;(std::is_invocable_r&lt; void, typename std::remove_pointer&lt; typename select_last&lt; PARAMS... &gt;::type &gt;::type, const cb_error &amp;&gt;::value||std::is_invocable_r&lt; void, typename std::remove_pointer&lt; typename select_last&lt; PARAMS... &gt;::type &gt;::type, const cb_error &amp;, sp_data_reader &gt;::value||std::is_invocable_r&lt; void, typename std::remove_pointer&lt; typename select_last&lt; PARAMS... &gt;::type &gt;::type &gt;::value||std::is_invocable_r&lt; void, typename std::remove_pointer&lt; typename select_last&lt; PARAMS... &gt;::type &gt;::type, sp_data_reader &gt;::value), int32_t &gt;::type  = -1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pq_async::database::query_reader </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>sql</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PARAMS &amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>asynchrounously process a query and returns a <a class="el" href="classpq__async_1_1data__reader.html">pq_async::data_reader</a> as the result </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">PARAMS</td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="data__common_8h.html#ac1db2b7cac33dd3352f33ea8b100ec26">PQ_ASYNC_VALID_DB_CALLBACK(sp_data_reader)</a></td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sql</td><td>the SQL query to process </td></tr>
    <tr><td class="paramname">args</td><td>query parameters, the last parameter is the query callback <a class="el" href="namespacepq__async.html#a10ae432e13a6cd45e3151d8203e3df67">pq_async::value_cb&lt;sp_data_reader&gt;</a> </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="namespacepq__async.html#abb8c48ea4f371f0fcf113c99e584f5c0">pq_async::get_last()</a>, <a class="el" href="classpq__async_1_1database.html#a887fd67d3c7dde55f81ed00e444f2b6f">open_connection()</a>, and <a class="el" href="classpq__async_1_1parameters.html#ab36da32fc50a4772c084321bbfd3b4b6">pq_async::parameters::push_back()</a>.</p>

</div>
</div>
<a id="aa20c3a797bfe97ac855bfc495f18c15d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa20c3a797bfe97ac855bfc495f18c15d">&#9670;&nbsp;</a></span>query_reader() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename std::enable_if&lt; !std::is_array&lt; typename std::remove_pointer&lt; T &gt;::type &gt;::value &amp;&amp;(std::is_invocable_r&lt; void, typename std::remove_pointer&lt; T &gt;::type, const cb_error &amp;&gt;::value||std::is_invocable_r&lt; void, typename std::remove_pointer&lt; T &gt;::type, const cb_error &amp;, sp_data_reader &gt;::value||std::is_invocable_r&lt; void, typename std::remove_pointer&lt; T &gt;::type &gt;::value||std::is_invocable_r&lt; void, typename std::remove_pointer&lt; T &gt;::type, sp_data_reader &gt;::value), int32_t &gt;::type  = -1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pq_async::database::query_reader </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>sql</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpq__async_1_1parameters.html">parameters</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>acb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>asynchrounously process a query and returns a <a class="el" href="classpq__async_1_1data__reader.html">pq_async::data_reader</a> as the result </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="data__common_8h.html#a4ee3eac68c7f1f882e04611fc54cce06">PQ_ASYNC_VALID_DB_VAL_CALLBACK(T</a>,sp_data_reader)</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sql</td><td>the SQL query to process </td></tr>
    <tr><td class="paramname">p</td><td>query parameters </td></tr>
    <tr><td class="paramname">acb</td><td>completion void(const cb_error&amp;, sp_data_reader) callback </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classpq__async_1_1database.html#a887fd67d3c7dde55f81ed00e444f2b6f">open_connection()</a>, and <a class="el" href="data__common_8h.html#ae45378768871c363d5d9d3c8e8a61155">PQ_ASYNC_INVALID_DB_CALLBACK</a>.</p>

</div>
</div>
<a id="a151fafcba2ea091cbeb120db77358a7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a151fafcba2ea091cbeb120db77358a7e">&#9670;&nbsp;</a></span>query_reader() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... PARAMS, typename std::enable_if&lt; std::is_same&lt; sp_data_reader, typename std::remove_pointer&lt; typename select_last&lt; PARAMS... &gt;::type &gt;::type &gt;::value||std::is_array&lt; typename std::remove_pointer&lt; typename select_last&lt; PARAMS... &gt;::type &gt;::type &gt;::value||(!std::is_invocable_r&lt; void, typename std::remove_pointer&lt; typename select_last&lt; PARAMS... &gt;::type &gt;::type, const cb_error &amp;&gt;::value &amp;&amp;!std::is_invocable_r&lt; void, typename std::remove_pointer&lt; typename select_last&lt; PARAMS... &gt;::type &gt;::type, const cb_error &amp;, sp_data_reader &gt;::value &amp;&amp;!std::is_invocable_r&lt; void, typename std::remove_pointer&lt; typename select_last&lt; PARAMS... &gt;::type &gt;::type &gt;::value &amp;&amp;!std::is_invocable_r&lt; void, typename std::remove_pointer&lt; typename select_last&lt; PARAMS... &gt;::type &gt;::type, sp_data_reader &gt;::value), int32_t &gt;::type  = -1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacepq__async.html#a44721d94c016db8d76a4360705dbe3a2">sp_data_reader</a> pq_async::database::query_reader </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>sql</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PARAMS &amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>synchrounously process a query and returns a <a class="el" href="classpq__async_1_1data__reader.html">pq_async::data_reader</a> as the result </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">PARAMS</td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="data__common_8h.html#ae45378768871c363d5d9d3c8e8a61155">PQ_ASYNC_INVALID_DB_CALLBACK(sp_data_reader)</a></td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sql</td><td>the SQL query to process </td></tr>
    <tr><td class="paramname">args</td><td>query parameters </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>sp_data_reader </dd></dl>

<p class="reference">References <a class="el" href="classpq__async_1_1database.html#a887fd67d3c7dde55f81ed00e444f2b6f">open_connection()</a>.</p>

</div>
</div>
<a id="a5cecfc496a504dd4ce828332e742d70a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cecfc496a504dd4ce828332e742d70a">&#9670;&nbsp;</a></span>query_reader() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacepq__async.html#a44721d94c016db8d76a4360705dbe3a2">sp_data_reader</a> pq_async::database::query_reader </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>sql</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>synchrounously process a query and returns a <a class="el" href="classpq__async_1_1data__reader.html">pq_async::data_reader</a> as the result </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sql</td><td>the SQL query to process </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>sp_data_reader </dd></dl>

<p class="reference">References <a class="el" href="classpq__async_1_1database.html#a887fd67d3c7dde55f81ed00e444f2b6f">open_connection()</a>.</p>

</div>
</div>
<a id="ad1e27663e53abadf5a3b1690a5ebf43e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1e27663e53abadf5a3b1690a5ebf43e">&#9670;&nbsp;</a></span>query_reader() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacepq__async.html#a44721d94c016db8d76a4360705dbe3a2">sp_data_reader</a> pq_async::database::query_reader </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>sql</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpq__async_1_1parameters.html">parameters</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>synchrounously process a query and returns a <a class="el" href="classpq__async_1_1data__reader.html">pq_async::data_reader</a> as the result </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sql</td><td>the SQL query to process </td></tr>
    <tr><td class="paramname">p</td><td>query parameters </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>sp_data_reader </dd></dl>

<p class="reference">References <a class="el" href="classpq__async_1_1database.html#a36417ad306bdddfba2eb5540df441992">create_lo()</a>, <a class="el" href="classpq__async_1_1database.html#a58b13b3e292e1d10fbb3c88d3f8e7c97">exec_queries()</a>, <a class="el" href="classpq__async_1_1database.html#a1223a9842f13669c41571d26df2bf55d">get_lo()</a>, and <a class="el" href="classpq__async_1_1database.html#a887fd67d3c7dde55f81ed00e444f2b6f">open_connection()</a>.</p>

</div>
</div>
<a id="a1a1cc72e1ecc5af712a79c15770c0a39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a1cc72e1ecc5af712a79c15770c0a39">&#9670;&nbsp;</a></span>query_single() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... PARAMS, typename std::enable_if&lt; !std::is_same&lt; sp_data_row, typename std::remove_pointer&lt; typename select_last&lt; PARAMS... &gt;::type &gt;::type &gt;::value &amp;&amp;!std::is_array&lt; typename std::remove_pointer&lt; typename select_last&lt; PARAMS... &gt;::type &gt;::type &gt;::value &amp;&amp;(std::is_invocable_r&lt; void, typename std::remove_pointer&lt; typename select_last&lt; PARAMS... &gt;::type &gt;::type, const cb_error &amp;&gt;::value||std::is_invocable_r&lt; void, typename std::remove_pointer&lt; typename select_last&lt; PARAMS... &gt;::type &gt;::type, const cb_error &amp;, sp_data_row &gt;::value||std::is_invocable_r&lt; void, typename std::remove_pointer&lt; typename select_last&lt; PARAMS... &gt;::type &gt;::type &gt;::value||std::is_invocable_r&lt; void, typename std::remove_pointer&lt; typename select_last&lt; PARAMS... &gt;::type &gt;::type, sp_data_row &gt;::value), int32_t &gt;::type  = -1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pq_async::database::query_single </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>sql</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PARAMS &amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>asynchrounously process a query and returns a <a class="el" href="classpq__async_1_1data__row.html">pq_async::data_row</a> as the result </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">PARAMS</td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="data__common_8h.html#ac1db2b7cac33dd3352f33ea8b100ec26">PQ_ASYNC_VALID_DB_CALLBACK(sp_data_row)</a></td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sql</td><td>the SQL query to process </td></tr>
    <tr><td class="paramname">args</td><td>query parameters, the last parameter is the completion void(const cb_error&amp;, sp_data_row) callback </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="database_8h.html#ae7d37c8d7f7d03ad0b6d47469d8b7fb5">_PQ_ASYNC_SEND_QRY_BODY_PARAMS</a>.</p>

</div>
</div>
<a id="ab5e352b399af7bc4b62bf79b42ae10c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5e352b399af7bc4b62bf79b42ae10c7">&#9670;&nbsp;</a></span>query_single() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename std::enable_if&lt; !std::is_array&lt; typename std::remove_pointer&lt; T &gt;::type &gt;::value &amp;&amp;(std::is_invocable_r&lt; void, typename std::remove_pointer&lt; T &gt;::type, const cb_error &amp;&gt;::value||std::is_invocable_r&lt; void, typename std::remove_pointer&lt; T &gt;::type, const cb_error &amp;, sp_data_row &gt;::value||std::is_invocable_r&lt; void, typename std::remove_pointer&lt; T &gt;::type &gt;::value||std::is_invocable_r&lt; void, typename std::remove_pointer&lt; T &gt;::type, sp_data_row &gt;::value), int32_t &gt;::type  = -1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pq_async::database::query_single </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>sql</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpq__async_1_1parameters.html">parameters</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>acb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>asynchrounously process a query and returns a <a class="el" href="classpq__async_1_1data__row.html">pq_async::data_row</a> as the result </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="data__common_8h.html#a4ee3eac68c7f1f882e04611fc54cce06">PQ_ASYNC_VALID_DB_VAL_CALLBACK(T</a>,sp_data_row)</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sql</td><td>the SQL query to process </td></tr>
    <tr><td class="paramname">p</td><td>query parameters </td></tr>
    <tr><td class="paramname">acb</td><td>the completion void(const cb_error&amp;, sp_data_row) callback </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="database_8h.html#af440556d7928b1cd6d84eefacbd73ae4">_PQ_ASYNC_SEND_QRY_BODY_T</a>, and <a class="el" href="data__common_8h.html#ae45378768871c363d5d9d3c8e8a61155">PQ_ASYNC_INVALID_DB_CALLBACK</a>.</p>

</div>
</div>
<a id="a826d8cee3bc6f902b8e8341e9e281f85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a826d8cee3bc6f902b8e8341e9e281f85">&#9670;&nbsp;</a></span>query_single() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... PARAMS, typename std::enable_if&lt; std::is_same&lt; sp_data_row, typename std::remove_pointer&lt; typename select_last&lt; PARAMS... &gt;::type &gt;::type &gt;::value||std::is_array&lt; typename std::remove_pointer&lt; typename select_last&lt; PARAMS... &gt;::type &gt;::type &gt;::value||(!std::is_invocable_r&lt; void, typename std::remove_pointer&lt; typename select_last&lt; PARAMS... &gt;::type &gt;::type, const cb_error &amp;&gt;::value &amp;&amp;!std::is_invocable_r&lt; void, typename std::remove_pointer&lt; typename select_last&lt; PARAMS... &gt;::type &gt;::type, const cb_error &amp;, sp_data_row &gt;::value &amp;&amp;!std::is_invocable_r&lt; void, typename std::remove_pointer&lt; typename select_last&lt; PARAMS... &gt;::type &gt;::type &gt;::value &amp;&amp;!std::is_invocable_r&lt; void, typename std::remove_pointer&lt; typename select_last&lt; PARAMS... &gt;::type &gt;::type, sp_data_row &gt;::value), int32_t &gt;::type  = -1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacepq__async.html#a496df213d664fd4fbc3835f2db9dd5ea">sp_data_row</a> pq_async::database::query_single </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>sql</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PARAMS &amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>synchrounously process a query and returns a <a class="el" href="classpq__async_1_1data__row.html">pq_async::data_row</a> as the result </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">PARAMS</td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="data__common_8h.html#ae45378768871c363d5d9d3c8e8a61155">PQ_ASYNC_INVALID_DB_CALLBACK(sp_data_row)</a></td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sql</td><td>the SQL query to process </td></tr>
    <tr><td class="paramname">args</td><td>query parameters </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>sp_data_row </dd></dl>

<p class="reference">References <a class="el" href="database_8h.html#a8e456322de870321e78f8703b2581bb1">_PQ_ASYNC_SEND_QRY_BODY_SYNC</a>.</p>

</div>
</div>
<a id="af30193b4e5ac17af590341e77047290c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af30193b4e5ac17af590341e77047290c">&#9670;&nbsp;</a></span>query_single() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacepq__async.html#a496df213d664fd4fbc3835f2db9dd5ea">sp_data_row</a> pq_async::database::query_single </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>sql</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>synchrounously process a query and returns a <a class="el" href="classpq__async_1_1data__row.html">pq_async::data_row</a> as the result </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sql</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>sp_data_row </dd></dl>

<p class="reference">References <a class="el" href="database_8h.html#a8e456322de870321e78f8703b2581bb1">_PQ_ASYNC_SEND_QRY_BODY_SYNC</a>.</p>

</div>
</div>
<a id="a40153102f9a6e31ffc3e2e0b46a7f576"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40153102f9a6e31ffc3e2e0b46a7f576">&#9670;&nbsp;</a></span>query_single() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacepq__async.html#a496df213d664fd4fbc3835f2db9dd5ea">sp_data_row</a> pq_async::database::query_single </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>sql</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpq__async_1_1parameters.html">parameters</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>synchrounously process a query and returns a <a class="el" href="classpq__async_1_1data__row.html">pq_async::data_row</a> as the result </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sql</td><td>the SQL query to process </td></tr>
    <tr><td class="paramname">p</td><td>query parameters </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>sp_data_row </dd></dl>

<p class="reference">References <a class="el" href="database_8h.html#a8e456322de870321e78f8703b2581bb1">_PQ_ASYNC_SEND_QRY_BODY_SYNC</a>, and <a class="el" href="data__common_8h.html#ac1db2b7cac33dd3352f33ea8b100ec26">PQ_ASYNC_VALID_DB_CALLBACK</a>.</p>

</div>
</div>
<a id="a453a701d0471cc919e2c0bd411f1e990"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a453a701d0471cc919e2c0bd411f1e990">&#9670;&nbsp;</a></span>query_value() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename... PARAMS, typename std::enable_if&lt; !std::is_same&lt; R, typename std::remove_pointer&lt; typename select_last&lt; PARAMS... &gt;::type &gt;::type &gt;::value &amp;&amp;!std::is_array&lt; typename std::remove_pointer&lt; typename select_last&lt; PARAMS... &gt;::type &gt;::type &gt;::value &amp;&amp;(std::is_invocable_r&lt; void, typename std::remove_pointer&lt; typename select_last&lt; PARAMS... &gt;::type &gt;::type, const cb_error &amp;&gt;::value||std::is_invocable_r&lt; void, typename std::remove_pointer&lt; typename select_last&lt; PARAMS... &gt;::type &gt;::type, const cb_error &amp;, R &gt;::value||std::is_invocable_r&lt; void, typename std::remove_pointer&lt; typename select_last&lt; PARAMS... &gt;::type &gt;::type &gt;::value||std::is_invocable_r&lt; void, typename std::remove_pointer&lt; typename select_last&lt; PARAMS... &gt;::type &gt;::type, R &gt;::value), int32_t &gt;::type  = -1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pq_async::database::query_value </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>sql</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PARAMS &amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>asynchrounously process a query and returns a scalar value as the result </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>the result type </td></tr>
    <tr><td class="paramname">PARAMS</td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="data__common_8h.html#ac1db2b7cac33dd3352f33ea8b100ec26">PQ_ASYNC_VALID_DB_CALLBACK(R)</a></td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sql</td><td>the SQL query to process </td></tr>
    <tr><td class="paramname">args</td><td>query parameters, the last parameter is the query callback <a class="el" href="namespacepq__async.html#a10ae432e13a6cd45e3151d8203e3df67">pq_async::value_cb&lt;R&gt;</a> </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="database_8h.html#ae7d37c8d7f7d03ad0b6d47469d8b7fb5">_PQ_ASYNC_SEND_QRY_BODY_PARAMS</a>, and <a class="el" href="data__common_8h.html#a4ee3eac68c7f1f882e04611fc54cce06">PQ_ASYNC_VALID_DB_VAL_CALLBACK</a>.</p>

</div>
</div>
<a id="abd127e1c68dbdcb389bd647b5b228936"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd127e1c68dbdcb389bd647b5b228936">&#9670;&nbsp;</a></span>query_value() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename T , typename std::enable_if&lt; !std::is_array&lt; typename std::remove_pointer&lt; T &gt;::type &gt;::value &amp;&amp;(std::is_invocable_r&lt; void, typename std::remove_pointer&lt; T &gt;::type, const cb_error &amp;&gt;::value||std::is_invocable_r&lt; void, typename std::remove_pointer&lt; T &gt;::type, const cb_error &amp;, R &gt;::value||std::is_invocable_r&lt; void, typename std::remove_pointer&lt; T &gt;::type &gt;::value||std::is_invocable_r&lt; void, typename std::remove_pointer&lt; T &gt;::type, R &gt;::value), int32_t &gt;::type  = -1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pq_async::database::query_value </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>sql</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpq__async_1_1parameters.html">parameters</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>acb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>asynchrounously process a query and returns a scalar value as the result </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td></td></tr>
    <tr><td class="paramname">T</td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="data__common_8h.html#a4ee3eac68c7f1f882e04611fc54cce06">PQ_ASYNC_VALID_DB_VAL_CALLBACK(T</a>,R)</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sql</td><td>the SQL query to process </td></tr>
    <tr><td class="paramname">p</td><td>query parameters </td></tr>
    <tr><td class="paramname">acb</td><td>completion void(const cb_error&amp;, R) callback </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="database_8h.html#af440556d7928b1cd6d84eefacbd73ae4">_PQ_ASYNC_SEND_QRY_BODY_T</a>, and <a class="el" href="data__common_8h.html#ae45378768871c363d5d9d3c8e8a61155">PQ_ASYNC_INVALID_DB_CALLBACK</a>.</p>

</div>
</div>
<a id="aa21ab335761fe0f00f2c551ffb33721f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa21ab335761fe0f00f2c551ffb33721f">&#9670;&nbsp;</a></span>query_value() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename... PARAMS, typename std::enable_if&lt; std::is_same&lt; R, typename std::remove_pointer&lt; typename select_last&lt; PARAMS... &gt;::type &gt;::type &gt;::value||std::is_array&lt; typename std::remove_pointer&lt; typename select_last&lt; PARAMS... &gt;::type &gt;::type &gt;::value||(!std::is_invocable_r&lt; void, typename std::remove_pointer&lt; typename select_last&lt; PARAMS... &gt;::type &gt;::type, const cb_error &amp;&gt;::value &amp;&amp;!std::is_invocable_r&lt; void, typename std::remove_pointer&lt; typename select_last&lt; PARAMS... &gt;::type &gt;::type, const cb_error &amp;, R &gt;::value &amp;&amp;!std::is_invocable_r&lt; void, typename std::remove_pointer&lt; typename select_last&lt; PARAMS... &gt;::type &gt;::type &gt;::value &amp;&amp;!std::is_invocable_r&lt; void, typename std::remove_pointer&lt; typename select_last&lt; PARAMS... &gt;::type &gt;::type, R &gt;::value), int32_t &gt;::type  = -1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">R pq_async::database::query_value </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>sql</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PARAMS &amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>synchrounously process a query and returns a scalar value as the result </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>the result type </td></tr>
    <tr><td class="paramname">PARAMS</td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="data__common_8h.html#ae45378768871c363d5d9d3c8e8a61155">PQ_ASYNC_INVALID_DB_CALLBACK(R)</a></td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sql</td><td>the SQL query to process </td></tr>
    <tr><td class="paramname">args</td><td>query parameters </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>R the scalar value </dd></dl>

<p class="reference">References <a class="el" href="database_8h.html#a8e456322de870321e78f8703b2581bb1">_PQ_ASYNC_SEND_QRY_BODY_SYNC</a>.</p>

</div>
</div>
<a id="a6b0f04f7a80942f1e0cdbdbdb6c816a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b0f04f7a80942f1e0cdbdbdb6c816a0">&#9670;&nbsp;</a></span>query_value() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">R pq_async::database::query_value </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>sql</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>synchrounously process a query and returns a scalar value as the result </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sql</td><td>the SQL query to process </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>R </dd></dl>

<p class="reference">References <a class="el" href="database_8h.html#a8e456322de870321e78f8703b2581bb1">_PQ_ASYNC_SEND_QRY_BODY_SYNC</a>.</p>

</div>
</div>
<a id="adfff557ed62272313820e52aa8f9777f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfff557ed62272313820e52aa8f9777f">&#9670;&nbsp;</a></span>query_value() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">R pq_async::database::query_value </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>sql</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpq__async_1_1parameters.html">parameters</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>synchrounously process a query and returns a scalar value as the result </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sql</td><td>the SQL query to process </td></tr>
    <tr><td class="paramname">p</td><td>query parameters </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>R </dd></dl>

<p class="reference">References <a class="el" href="database_8h.html#a8e456322de870321e78f8703b2581bb1">_PQ_ASYNC_SEND_QRY_BODY_SYNC</a>, and <a class="el" href="data__common_8h.html#ac1db2b7cac33dd3352f33ea8b100ec26">PQ_ASYNC_VALID_DB_CALLBACK</a>.</p>

</div>
</div>
<a id="a4a41daa5b5b2dec092e3bdde8c3d6500"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a41daa5b5b2dec092e3bdde8c3d6500">&#9670;&nbsp;</a></span>release_savepoint() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pq_async::database::release_savepoint </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>synchonously release the specified savepoint </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td></td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classpq__async_1_1connection.html#a25af0e01b7f1e0ad06145f6fa2b1b34a">pq_async::connection::release_savepoint()</a>.</p>

</div>
</div>
<a id="a9c602c9c427368e0d11fdc585bab9da5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c602c9c427368e0d11fdc585bab9da5">&#9670;&nbsp;</a></span>release_savepoint() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CB , typename std::enable_if&lt; !std::is_array&lt; typename std::remove_pointer&lt; CB &gt;::type &gt;::value &amp;&amp;(std::is_invocable_r&lt; void, typename std::remove_pointer&lt; CB &gt;::type, const cb_error &amp;&gt;::value||std::is_invocable_r&lt; void, typename std::remove_pointer&lt; CB &gt;::type &gt;::value), int32_t &gt;::type  = -1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pq_async::database::release_savepoint </td>
          <td>(</td>
          <td class="paramtype">const CB &amp;&#160;</td>
          <td class="paramname"><em>acb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>asynchonously release the specified savepoint </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">CB</td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="data__common_8h.html#a6b856e51a0c469de2ead306082dd9eb6">PQ_ASYNC_VALID_DB_ASY_CALLBACK(CB)</a></td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acb</td><td></td></tr>
    <tr><td class="paramname">name</td><td></td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classpq__async_1_1database.html#a9fd6245f84aa5051a88cba192608b9d2">execute()</a>, <a class="el" href="classpq__async_1_1database.html#a6ba12ad8ec40562af85d896cb5ba2f52">in_transaction()</a>, <a class="el" href="namespacepq__async.html#a373c59a26966d87407b5fe7e0f174b8e">pq_async::s</a>, and <a class="el" href="classpq__async_1_1connection.html#ad554218d7ff7972263600dfd1db6edb8">pq_async::connection::touch()</a>.</p>

</div>
</div>
<a id="a9b71c15239af2889c8697a805cf6bd86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b71c15239af2889c8697a805cf6bd86">&#9670;&nbsp;</a></span>rollback()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pq_async::database::rollback </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>synchonously rollback current transaction </p>

<p class="reference">References <a class="el" href="classpq__async_1_1connection.html#a16adc5a5beee84a813e84f28a79fde1d">pq_async::connection::rollback_transaction()</a>.</p>

</div>
</div>
<a id="a6f48ccb20299b05f703976a477692a29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f48ccb20299b05f703976a477692a29">&#9670;&nbsp;</a></span>rollback_savepoint() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pq_async::database::rollback_savepoint </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>synchonously rollback the specified savepoint </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td></td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classpq__async_1_1connection.html#a31e01b1356fb8f24342a8a157d2debcc">pq_async::connection::rollback_savepoint()</a>.</p>

</div>
</div>
<a id="ab347754cd442aa93a1cd6201036c49c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab347754cd442aa93a1cd6201036c49c5">&#9670;&nbsp;</a></span>rollback_savepoint() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CB , typename std::enable_if&lt; !std::is_array&lt; typename std::remove_pointer&lt; CB &gt;::type &gt;::value &amp;&amp;(std::is_invocable_r&lt; void, typename std::remove_pointer&lt; CB &gt;::type, const cb_error &amp;&gt;::value||std::is_invocable_r&lt; void, typename std::remove_pointer&lt; CB &gt;::type &gt;::value), int32_t &gt;::type  = -1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pq_async::database::rollback_savepoint </td>
          <td>(</td>
          <td class="paramtype">const CB &amp;&#160;</td>
          <td class="paramname"><em>acb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>asynchonously rollback the specified savepoint </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">CB</td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="data__common_8h.html#a6b856e51a0c469de2ead306082dd9eb6">PQ_ASYNC_VALID_DB_ASY_CALLBACK(CB)</a></td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acb</td><td></td></tr>
    <tr><td class="paramname">name</td><td></td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classpq__async_1_1database.html#a9fd6245f84aa5051a88cba192608b9d2">execute()</a>, <a class="el" href="classpq__async_1_1database.html#a6ba12ad8ec40562af85d896cb5ba2f52">in_transaction()</a>, <a class="el" href="data__common_8h.html#ac1db2b7cac33dd3352f33ea8b100ec26">PQ_ASYNC_VALID_DB_CALLBACK</a>, <a class="el" href="namespacepq__async.html#a373c59a26966d87407b5fe7e0f174b8e">pq_async::s</a>, and <a class="el" href="classpq__async_1_1connection.html#ad554218d7ff7972263600dfd1db6edb8">pq_async::connection::touch()</a>.</p>

</div>
</div>
<a id="a5ac85db4dec7a56ad44309bc18f02670"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ac85db4dec7a56ad44309bc18f02670">&#9670;&nbsp;</a></span>roollback()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CB , typename std::enable_if&lt; !std::is_array&lt; typename std::remove_pointer&lt; CB &gt;::type &gt;::value &amp;&amp;(std::is_invocable_r&lt; void, typename std::remove_pointer&lt; CB &gt;::type, const cb_error &amp;&gt;::value||std::is_invocable_r&lt; void, typename std::remove_pointer&lt; CB &gt;::type &gt;::value), int32_t &gt;::type  = -1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pq_async::database::roollback </td>
          <td>(</td>
          <td class="paramtype">const CB &amp;&#160;</td>
          <td class="paramname"><em>acb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>asynchonously rollback current transaction </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">CB</td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="data__common_8h.html#a6b856e51a0c469de2ead306082dd9eb6">PQ_ASYNC_VALID_DB_ASY_CALLBACK(CB)</a></td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acb</td><td></td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classpq__async_1_1database.html#a9fd6245f84aa5051a88cba192608b9d2">execute()</a>, <a class="el" href="classpq__async_1_1database.html#a6ba12ad8ec40562af85d896cb5ba2f52">in_transaction()</a>, and <a class="el" href="classpq__async_1_1connection.html#ad554218d7ff7972263600dfd1db6edb8">pq_async::connection::touch()</a>.</p>

</div>
</div>
<a id="a92dc82644347b9bdc081768f80e372f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92dc82644347b9bdc081768f80e372f5">&#9670;&nbsp;</a></span>set_savepoint() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pq_async::database::set_savepoint </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>synchronously sets a new savepoint inside the current transaction </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>the savepoint name </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classpq__async_1_1connection.html#af7e80c3820fc1d280e5648f99f56b139">pq_async::connection::set_savepoint()</a>.</p>

</div>
</div>
<a id="acb121211b73fffdb837881a04361c830"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb121211b73fffdb837881a04361c830">&#9670;&nbsp;</a></span>set_savepoint() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CB , typename std::enable_if&lt; !std::is_array&lt; typename std::remove_pointer&lt; CB &gt;::type &gt;::value &amp;&amp;(std::is_invocable_r&lt; void, typename std::remove_pointer&lt; CB &gt;::type, const cb_error &amp;&gt;::value||std::is_invocable_r&lt; void, typename std::remove_pointer&lt; CB &gt;::type &gt;::value), int32_t &gt;::type  = -1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pq_async::database::set_savepoint </td>
          <td>(</td>
          <td class="paramtype">const CB &amp;&#160;</td>
          <td class="paramname"><em>acb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>asynchronously sets a new savepoint inside the current transaction </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">CB</td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="data__common_8h.html#a6b856e51a0c469de2ead306082dd9eb6">PQ_ASYNC_VALID_DB_ASY_CALLBACK(CB)</a></td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acb</td><td></td></tr>
    <tr><td class="paramname">name</td><td></td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classpq__async_1_1database.html#a9fd6245f84aa5051a88cba192608b9d2">execute()</a>, <a class="el" href="classpq__async_1_1database.html#a6ba12ad8ec40562af85d896cb5ba2f52">in_transaction()</a>, <a class="el" href="namespacepq__async.html#a373c59a26966d87407b5fe7e0f174b8e">pq_async::s</a>, and <a class="el" href="classpq__async_1_1connection.html#ad554218d7ff7972263600dfd1db6edb8">pq_async::connection::touch()</a>.</p>

</div>
</div>
<a id="a4aad3ca4426bb15ee85948bd0a66bc2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4aad3ca4426bb15ee85948bd0a66bc2e">&#9670;&nbsp;</a></span>split_queries()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pq_async::database::split_queries </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sql</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>queries</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="log_8h.html#a50b79ae676f191c1f7761a31e81ffadc">pq_async_log_trace</a>, and <a class="el" href="namespacepq__async.html#a7ec0a33888257616c17f6fc6844f5a6c">pq_async::trim()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classpq__async_1_1database.html#acb8dac3663f64ba3b956b3b5517cd225">open()</a>.</p>

</div>
</div>
<a id="a35e2b15a91190f410df94162f6f0c13b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35e2b15a91190f410df94162f6f0c13b">&#9670;&nbsp;</a></span>working()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pq_async::database::working </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns true if the database is currently working. </p>
<dl class="section return"><dt>Returns</dt><dd>true </dd>
<dd>
false </dd></dl>

<p class="reference">References <a class="el" href="classpq__async_1_1connection.html#a9df28cd9b602174b9dd566ca72132122">pq_async::connection::running()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classpq__async_1_1database.html#acb8dac3663f64ba3b956b3b5517cd225">open()</a>.</p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="adb115488bb4890f7fc705ee527ad71e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb115488bb4890f7fc705ee527ad71e0">&#9670;&nbsp;</a></span>connection</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classpq__async_1_1connection.html">connection</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="accac599643e0a8c900f765dcf4026344"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accac599643e0a8c900f765dcf4026344">&#9670;&nbsp;</a></span>connection_pool</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classpq__async_1_1connection__pool.html">connection_pool</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="afab4905b271f8aabf42aecc3e1f14a93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afab4905b271f8aabf42aecc3e1f14a93">&#9670;&nbsp;</a></span>connection_task</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classpq__async_1_1connection__task.html">connection_task</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad3648c32fa13464804de0657935a79c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3648c32fa13464804de0657935a79c7">&#9670;&nbsp;</a></span>data_large_object</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classpq__async_1_1data__large__object.html">data_large_object</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac9f2c5c4fb0dc288d001d1f9b415b51d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9f2c5c4fb0dc288d001d1f9b415b51d">&#9670;&nbsp;</a></span>data_prepared</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classpq__async_1_1data__prepared.html">data_prepared</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/<a class="el" href="database_8h_source.html">database.h</a></li>
<li>src/<a class="el" href="database_8cpp.html">database.cpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacepq__async.html">pq_async</a></li><li class="navelem"><a class="el" href="classpq__async_1_1database.html">database</a></li>
    <li class="footer">Generated on Thu Dec 20 2018 11:43:46 for libpq-async++ by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
